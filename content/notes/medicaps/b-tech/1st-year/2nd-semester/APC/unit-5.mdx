---
title: "Unit 5: Advanced Programming with C"
description: C Header Files for handling graphics and initializing graphics mode, Understand Coordinate system, Function to Draw Lines, Circle, Arc, Ellipse, pieslice, sector,  Rectangle, Bar, 3-D Bars & Polygon. Color Spraying filling Ellipse, polygons and flooding the fills, Filling Styles and Patterns, Understand Animation, Function to create Animation, Traffic Light and Moving Car Simulation. 
date: 2025-01-14
tags: ["Advanced Programming with C", "2nd Semester", "1st Year", "B Tech"]
published: true
metadata:
  university: "Medicaps University"
  degree: "B Tech"
  semester: "2nd Semester"
  subject: "Advanced Programming with C"
---

---

## C Header Files for Handling Graphics and Initializing Graphics Mode

### Introduction to Graphics in C
In C, **graphics programming** involves the creation of visual content, such as shapes, images, and animations, within a program. The C programming language doesn't have built-in support for graphics, but graphics can be handled using external libraries. One of the most common libraries for handling graphics in C is **graphics.h**, which is typically used with **Turbo C** and **Borland C++** compilers.

ðŸ’¡ **TIP:** Modern graphics libraries like **SDL** or **OpenGL** are commonly used today for graphical applications, but `graphics.h` is still useful for learning basic concepts of graphics programming.

---

### **1. `graphics.h` Header File**
The **`graphics.h`** header file is part of the older **Turbo C**/**Borland C** environment, and it provides functions for creating graphics applications. The functions within `graphics.h` allow you to initialize graphics mode, draw shapes, manipulate colors, and more.

#### Key Functions in `graphics.h`:
- **`initgraph()`**: Initializes the graphics mode.
- **`closegraph()`**: Closes the graphics mode and returns the program to text mode.
- **`setcolor()`**: Sets the color for drawing shapes.
- **`line()`**: Draws a line between two points.
- **`circle()`**: Draws a circle.
- **`rectangle()`**: Draws a rectangle.
- **`getmaxx()` and `getmaxy()`**: Get the maximum x and y coordinates for the graphics screen.

#### Example: Including `graphics.h` in Your Program
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");  // Initialize graphics mode

    // Drawing a line from (100, 100) to (200, 200)
    line(100, 100, 200, 200);

    getch();  // Wait for user input before closing
    closegraph();  // Close graphics mode

    return 0;
}
```

**Explanation:**
- `initgraph(&gd, &gm, "")` initializes the graphics mode. The `gd` and `gm` variables store the graphics driver and mode, which are automatically detected.
- `line(100, 100, 200, 200)` draws a line from (100, 100) to (200, 200).
- `closegraph()` closes the graphics window and returns the program to text mode.

---

### **2. Initializing Graphics Mode with `initgraph()`**
The `initgraph()` function is used to initialize the graphics mode. This is the first step in any graphics program using `graphics.h`. It sets up the graphics driver and mode and prepares the screen for graphical operations.

#### Syntax:
```c
int initgraph(int *gd, int *gm, const char *path);
```
- **`gd`**: A pointer to the graphics driver.
- **`gm`**: A pointer to the graphics mode.
- **`path`**: The path to the directory containing the graphics driver files. It is usually left empty to let the program automatically find the required files.

#### Example: Using `initgraph()` to Initialize Graphics
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");  // Detect and initialize the graphics mode

    // Drawing a simple shape (rectangle)
    rectangle(50, 50, 200, 200);

    getch();  // Wait for user input before closing
    closegraph();  // Close the graphics window

    return 0;
}
```

**Explanation:**
- `initgraph(&gd, &gm, "")` initializes the graphics mode by automatically detecting the driver and mode. The `gm` variable stores the graphics mode, and `gd` is set to `DETECT` to automatically detect the driver.

---

### **3. Closing the Graphics Mode with `closegraph()`**
Once the graphics operations are done, it is essential to close the graphics mode properly using `closegraph()` to free the resources and return the program to text mode.

#### Syntax:
```c
void closegraph();
```

#### Example: Using `closegraph()` to End the Graphics Mode
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");  // Initialize the graphics mode

    // Draw a circle at (200, 200) with radius 50
    circle(200, 200, 50);

    getch();  // Wait for user input before closing the graphics window
    closegraph();  // Close the graphics mode and return to text mode

    return 0;
}
```

**Explanation:**
- `closegraph()` is called after all graphics operations are completed to close the graphics window and release system resources.

---

### **4. Drawing Basic Shapes**
Once graphics mode is initialized, you can use various functions to draw basic shapes like lines, rectangles, circles, and more.

#### **`line()` Function:**
The `line()` function is used to draw a straight line between two specified points.

##### Syntax:
```c
void line(int x1, int y1, int x2, int y2);
```
- **`x1, y1`**: Coordinates of the starting point.
- **`x2, y2`**: Coordinates of the ending point.

#### Example: Drawing a Line
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Draw a line from (50, 50) to (200, 200)
    line(50, 50, 200, 200);

    getch();
    closegraph();

    return 0;
}
```

#### **`rectangle()` Function:**
The `rectangle()` function is used to draw a rectangle using two opposite corners.

##### Syntax:
```c
void rectangle(int left, int top, int right, int bottom);
```
- **`left, top`**: Coordinates of the top-left corner.
- **`right, bottom`**: Coordinates of the bottom-right corner.

#### Example: Drawing a Rectangle
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Draw a rectangle from (50, 50) to (200, 200)
    rectangle(50, 50, 200, 200);

    getch();
    closegraph();

    return 0;
}
```

#### **`circle()` Function:**
The `circle()` function is used to draw a circle at a specified center with a given radius.

##### Syntax:
```c
void circle(int x, int y, int radius);
```
- **`x, y`**: Coordinates of the center of the circle.
- **`radius`**: The radius of the circle.

#### Example: Drawing a Circle
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Draw a circle at (200, 200) with a radius of 50
    circle(200, 200, 50);

    getch();
    closegraph();

    return 0;
}
```

---

### **5. Manipulating Colors with `setcolor()`**
The `setcolor()` function allows you to set the color for drawing shapes and lines in graphics mode.

#### Syntax:
```c
void setcolor(int color);
```
- **`color`**: The color code for the drawing operations. For example, `RED`, `BLUE`, `GREEN`, etc.

#### Example: Using `setcolor()` to Set Colors
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    setcolor(RED);  // Set the color to red
    rectangle(50, 50, 200, 200);  // Draw a red rectangle

    setcolor(BLUE);  // Change the color to blue
    circle(200, 200, 50);  // Draw a blue circle

    getch();
    closegraph();

    return 0;
}
```

**Explanation:**
- `setcolor(RED)` sets the color to red before drawing the rectangle.
- `setcolor(BLUE)` changes the color to blue before drawing the circle.

---

### **6. Graphical Modes and Drivers**
The `graphics.h` library works with various graphical modes and drivers. The graphical mode determines the screen resolution, color depth, and graphics capabilities.

#### `DETECT` Mode:
The `DETECT` constant is used to automatically detect the graphics driver and mode that are supported by the system.

#### Example: Using `DETECT` to Automatically Set the Driver
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");  // Automatically detect the driver and mode

    // Drawing operations...

    getch();
    closegraph();

    return 0;
}
```

---

### Key Points:
- **`graphics.h`** provides functions for working with graphics in C, including drawing shapes, manipulating colors, and initializing graphics mode.
- **Graphics Mode Initialization:** The `initgraph()` function initializes the graphics mode, while `closegraph()` ends it.
- **Basic Shapes:** You can use functions like `line()`, `rectangle()`, and `circle()` to draw basic shapes.
- **Color Manipulation:** The `setcolor()` function allows you to set the drawing color for shapes and lines.

---

## Understand Coordinate System

### What is a Coordinate System in Graphics?
A **coordinate system** in graphics refers to a method of defining and representing the positions of points on a plane. It consists of a set of axes, typically horizontal (x-axis) and vertical (y-axis), which are used to determine the location of points. In computer graphics, the coordinate system plays a crucial role in positioning objects, drawing shapes, and rendering images.

ðŸ’¡ **TIP:** Understanding the coordinate system is essential for working with graphical operations such as positioning, scaling, and transformations.

---

### **1. Types of Coordinate Systems**
In computer graphics, two primary coordinate systems are used:
- **2D Coordinate System**: A two-dimensional system that represents points on a flat plane using two values: `x` (horizontal) and `y` (vertical).
- **3D Coordinate System**: An extension of the 2D system, adding a third dimension (`z`) for depth, allowing for three-dimensional representation of objects.

#### Example: 2D Coordinate System
In a 2D coordinate system, every point is represented by two values: `(x, y)`, where:
- `x` indicates the horizontal position.
- `y` indicates the vertical position.

---

### **2. The Cartesian Coordinate System**
The **Cartesian coordinate system** is the most widely used coordinate system in both mathematics and computer graphics. It consists of two perpendicular axes:
- **X-axis**: The horizontal axis, usually running left to right.
- **Y-axis**: The vertical axis, usually running bottom to top.

The point where the two axes intersect is called the **origin** (0, 0).

#### Example: Cartesian Coordinate System
- The point (5, 3) means 5 units to the right along the x-axis and 3 units up along the y-axis.
- The point (-4, -2) means 4 units to the left along the x-axis and 2 units down along the y-axis.

---

### **3. Coordinate System in Computer Graphics**
In computer graphics, the origin and axis orientation may vary depending on the system or library used. For example:
- **In typical graphics programming**, the origin `(0, 0)` is often at the top-left corner of the screen or window.
  - The x-axis increases from left to right.
  - The y-axis increases from top to bottom (reverse of traditional Cartesian coordinates).

#### Example: Coordinate System in C Graphics (`graphics.h`)
In many graphics libraries (like Turbo Câ€™s `graphics.h`), the origin `(0, 0)` is at the top-left corner of the window, and:
- **Positive x-values** move to the right.
- **Positive y-values** move downward.

#### Example: Drawing a Line in C Graphics
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Drawing a line from (100, 100) to (200, 200)
    line(100, 100, 200, 200);  // Coordinates in 2D screen space

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- The line starts from `(100, 100)` (100 units right and 100 units down from the origin) and ends at `(200, 200)`.

---

### **4. Screen Coordinates vs. Mathematical Coordinates**
In most graphical applications, the coordinate system used on the screen (or window) may not match the traditional Cartesian coordinate system. This discrepancy is due to the orientation of the y-axis.

#### **Screen Coordinates:**
- The **origin** is at the top-left corner.
- The **x-axis** increases to the right.
- The **y-axis** increases downward.

#### **Mathematical Coordinates:**
- The **origin** is at the center.
- The **x-axis** increases to the right.
- The **y-axis** increases upward.

---

### **5. Working with Different Coordinate Systems**
When dealing with graphics, you might need to work with various coordinate systems, such as:
- **World Coordinates**: Used to define points in a 3D scene, often in relation to the camera or view.
- **Screen Coordinates**: Used for positioning and rendering in the 2D screen space.
- **Object Coordinates**: Used for defining points relative to objects in a 3D scene or model.

---

### **6. Transformations in Coordinate Systems**
Transformations such as **translation**, **scaling**, and **rotation** are used to manipulate objects in the coordinate system.

#### **Translation:**
Translation involves shifting an object from one location to another in the coordinate system. It is achieved by adding values to the coordinates of the object.

#### Example: Translating a Point
```c
// Original coordinates (x, y)
int x = 5, y = 3;

// Translation vector (tx, ty)
int tx = 2, ty = 4;

// New coordinates after translation
x = x + tx;
y = y + ty;
```

- The new point after translation will be `(7, 7)`.

#### **Scaling:**
Scaling changes the size of an object. A scaling factor is applied to the x and y coordinates.

#### Example: Scaling a Point
```c
// Original coordinates (x, y)
int x = 5, y = 3;

// Scaling factor (sx, sy)
float sx = 2.0, sy = 1.5;

// New coordinates after scaling
x = x * sx;
y = y * sy;
```

- The new point after scaling will be `(10, 4.5)`.

#### **Rotation:**
Rotation changes the orientation of an object by rotating it around the origin (or another point). The angle of rotation is usually specified in degrees or radians.

#### Example: Rotating a Point (Using Trigonometry)
```c
#include <math.h>

// Original coordinates (x, y)
int x = 5, y = 3;

// Rotation angle (in radians)
float angle = M_PI / 4;  // 45 degrees

// Rotation matrix
int newX = (int)(x * cos(angle) - y * sin(angle));
int newY = (int)(x * sin(angle) + y * cos(angle));
```

- The new point will be the coordinates of the original point after a 45-degree rotation.

---

### **7. Coordinate Systems in 3D Graphics**
In 3D graphics, a third coordinate (z) is added to represent depth. The 3D coordinate system uses three axes:
- **X-axis**: Horizontal axis.
- **Y-axis**: Vertical axis.
- **Z-axis**: Depth axis (perpendicular to the screen).

#### Example: 3D Coordinates
- A point (5, 3, 2) means 5 units to the right along the x-axis, 3 units up along the y-axis, and 2 units in depth along the z-axis.

---

### Key Points:
- **Coordinate Systems**: In computer graphics, the coordinate system defines the position of points on the screen, with the origin typically at the top-left corner in 2D graphics.
- **Cartesian vs. Screen Coordinates**: Cartesian coordinates have the origin at the center and the y-axis increasing upwards, while screen coordinates have the origin at the top-left corner with the y-axis increasing downward.
- **Transformations**: Common transformations like translation, scaling, and rotation manipulate the positions of objects in the coordinate system.
- **3D Coordinates**: In 3D graphics, the z-axis represents depth, adding another dimension to the traditional 2D coordinate system.

---

## Functions to Draw Lines, Circle, Arc, Ellipse, Pieslice, Sector, Rectangle, Bar, 3-D Bars & Polygon

### Introduction to Drawing Shapes in Graphics
In graphics programming, various shapes such as lines, circles, rectangles, and polygons are fundamental to creating visual representations. The **`graphics.h`** library (commonly used in Turbo C or Borland C++) provides built-in functions to draw these shapes on the screen. These functions help you create basic visual elements, allowing for both 2D and 3D rendering.

ðŸ’¡ **TIP:** While `graphics.h` is an older library, modern graphics programming typically uses libraries like **OpenGL**, **DirectX**, or **SDL**. However, `graphics.h` still serves as a useful tool for understanding graphical concepts in C.

---

### **1. Drawing a Line: `line()`**
The `line()` function is used to draw a straight line between two points.

#### Syntax:
```c
void line(int x1, int y1, int x2, int y2);
```
- **`x1, y1`**: Coordinates of the starting point.
- **`x2, y2`**: Coordinates of the ending point.

#### Example: Drawing a Line
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Draw a line from (100, 100) to (200, 200)
    line(100, 100, 200, 200);

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `line(100, 100, 200, 200)` draws a line from the point (100, 100) to (200, 200).

---

### **2. Drawing a Circle: `circle()`**
The `circle()` function is used to draw a circle at a given center with a specified radius.

#### Syntax:
```c
void circle(int x, int y, int radius);
```
- **`x, y`**: Coordinates of the center of the circle.
- **`radius`**: Radius of the circle.

#### Example: Drawing a Circle
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Draw a circle at (200, 200) with radius 50
    circle(200, 200, 50);

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `circle(200, 200, 50)` draws a circle with a center at (200, 200) and a radius of 50.

---

### **3. Drawing an Arc: `arc()`**
The `arc()` function is used to draw an arc of a circle between two specified angles.

#### Syntax:
```c
void arc(int x, int y, int stangle, int endangle, int radius);
```
- **`x, y`**: Coordinates of the center of the circle.
- **`stangle`**: Starting angle of the arc (in degrees).
- **`endangle`**: Ending angle of the arc (in degrees).
- **`radius`**: Radius of the circle.

#### Example: Drawing an Arc
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Draw an arc with center at (200, 200), starting at 0 degrees and ending at 180 degrees
    arc(200, 200, 0, 180, 50);

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `arc(200, 200, 0, 180, 50)` draws an arc from 0 to 180 degrees with a radius of 50 at center (200, 200).

---

### **4. Drawing an Ellipse: `ellipse()`**
The `ellipse()` function is used to draw an ellipse, which is a stretched circle along one or both axes.

#### Syntax:
```c
void ellipse(int x, int y, int stangle, int endangle, int xradius, int yradius);
```
- **`x, y`**: Coordinates of the center of the ellipse.
- **`stangle`**: Starting angle of the ellipse.
- **`endangle`**: Ending angle of the ellipse.
- **`xradius`**: Radius along the x-axis.
- **`yradius`**: Radius along the y-axis.

#### Example: Drawing an Ellipse
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Draw an ellipse with center at (200, 200), x radius 100, and y radius 50
    ellipse(200, 200, 0, 360, 100, 50);

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `ellipse(200, 200, 0, 360, 100, 50)` draws a full ellipse with center (200, 200), x-radius 100, and y-radius 50.

---

### **5. Drawing a Pieslice: `pieslice()`**
The `pieslice()` function is used to draw a sector of a circle (similar to an arc, but with filled space).

#### Syntax:
```c
void pieslice(int x, int y, int stangle, int endangle, int radius);
```
- **`x, y`**: Coordinates of the center of the circle.
- **`stangle`**: Starting angle of the sector.
- **`endangle`**: Ending angle of the sector.
- **`radius`**: Radius of the circle.

#### Example: Drawing a Pieslice
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Draw a pieslice from 0 to 90 degrees with radius 50
    pieslice(200, 200, 0, 90, 50);

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `pieslice(200, 200, 0, 90, 50)` draws a sector (pieslice) from 0 to 90 degrees with a radius of 50.

---

### **6. Drawing a Rectangle: `rectangle()`**
The `rectangle()` function draws a rectangle defined by its opposite corners.

#### Syntax:
```c
void rectangle(int left, int top, int right, int bottom);
```
- **`left, top`**: Coordinates of the top-left corner.
- **`right, bottom`**: Coordinates of the bottom-right corner.

#### Example: Drawing a Rectangle
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Draw a rectangle from (50, 50) to (200, 200)
    rectangle(50, 50, 200, 200);

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `rectangle(50, 50, 200, 200)` draws a rectangle with the top-left corner at (50, 50) and the bottom-right corner at (200, 200).

---

### **7. Drawing Bars: `bar()`**
The `bar()` function is used to draw a filled rectangle or bar.

#### Syntax:
```c
void bar(int left, int top, int right, int bottom);
```
- **`left, top`**: Coordinates of the top-left corner.
- **`right, bottom`**: Coordinates of the bottom-right corner.

#### Example: Drawing a Bar
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Draw a filled bar from (50, 50) to (200, 200)
    bar(50, 50, 200, 200);

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `bar(50, 50, 200, 200)` draws a filled rectangle (bar) from (50, 50) to (200, 200).

---

### **8. Drawing 3-D Bars: `3dbar()`**
The `3dbar()` function is used to draw 3D-like bars in graphics mode.

#### Syntax:
```c
void 3dbar(int left, int top, int right, int bottom, int depth);
```
- **`left, top`**: Coordinates of the top-left corner.
- **`right, bottom`**: Coordinates of the bottom-right corner.
- **`depth`**: The depth or height of the 3D bar.

---

### **9. Drawing Polygons: `polygon()`**
The `polygon()` function is used to draw polygons by connecting a series of points.

#### Syntax:
```c
void polygon(int *points, int num_points);
```
- **`points`**: Array containing the coordinates of the polygonâ€™s vertices.
- **`num_points`**: Number of vertices in the polygon.

#### Example: Drawing a Polygon
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    int points[] = {100, 100, 150, 50, 200, 100, 150, 150};
    int num_points = 4;
    polygon(points, num_points);  // Draw a polygon

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- The `polygon()` function connects the points `(100, 100)`, `(150, 50)`, `(200, 100)`, and `(150, 150)` to form a polygon.

---

### Key Points:
- **Line**: `line()` draws straight lines between two points.
- **Circle**: `circle()` draws a circle with a specified radius.
- **Arc**: `arc()` draws a portion of a circle between two angles.
- **Ellipse**: `ellipse()` draws an ellipse with x and y radii.
- **Pieslice**: `pieslice()` draws a filled sector of a circle.
- **Rectangle**: `rectangle()` draws a rectangle from two points.
- **Bar**: `bar()` draws a filled rectangular bar.
- **3D Bars**: `3dbar()` draws a 3D-like bar.
- **Polygon**: `polygon()` connects multiple points to form a polygon.

---

## Color Spraying, Filling Ellipses, Polygons, and Flooding the Fills

### Introduction to Filling Shapes in Graphics
In computer graphics, filling shapes with color or patterns is a common technique used to add visual appeal and clarity. Filling functions in graphics libraries allow you to fill shapes like ellipses, polygons, and other shapes with specific colors or patterns. This process is known as **color filling** or **filling the interior** of a shape. In addition to simple color fills, techniques like **flood filling** or **spray filling** can be used to create effects that mimic spray painting or filling regions based on neighboring colors.

ðŸ’¡ **TIP:** Understanding how to fill shapes and use color in graphics allows you to create more dynamic and visually interesting applications.

---

### **1. Filling Shapes with `fill()` and `setfillstyle()`**
The `graphics.h` library provides functions like `setfillstyle()` to define the pattern or color used for filling shapes. Once the style is set, you can use functions like `floodfill()` or `fillpoly()` to fill the shapes.

#### **`setfillstyle()` Function:**
This function is used to set the filling style and color for shapes that will be drawn or filled.

##### Syntax:
```c
void setfillstyle(int pattern, int color);
```
- **`pattern`**: The fill pattern (e.g., solid, crosshatch, etc.).
- **`color`**: The fill color. You can use predefined color constants like `RED`, `GREEN`, `BLUE`, etc.

#### Example: Setting Fill Style
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    setfillstyle(SOLID_FILL, YELLOW);  // Set fill style to solid yellow color

    // Draw and fill a rectangle
    rectangle(50, 50, 200, 200);
    floodfill(100, 100, WHITE);  // Fill the rectangle with the set color

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `setfillstyle(SOLID_FILL, YELLOW)` sets the fill style to a solid yellow color.
- `floodfill(100, 100, WHITE)` fills the inside of the rectangle starting from the point (100, 100) with the color `YELLOW`.

---

### **2. Filling an Ellipse: `fillellipse()`**
The `fillellipse()` function is used to draw and fill an ellipse with a specific color or pattern.

#### Syntax:
```c
void fillellipse(int x, int y, int xradius, int yradius);
```
- **`x, y`**: Coordinates of the center of the ellipse.
- **`xradius`**: Radius along the x-axis.
- **`yradius`**: Radius along the y-axis.

#### Example: Filling an Ellipse
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    setfillstyle(SOLID_FILL, RED);  // Set fill color to red
    fillellipse(200, 200, 100, 50);  // Draw and fill an ellipse

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `fillellipse(200, 200, 100, 50)` draws an ellipse at (200, 200) with x-radius 100 and y-radius 50, then fills it with the red color.

---

### **3. Filling Polygons: `fillpoly()`**
The `fillpoly()` function is used to fill polygons defined by multiple vertices. You must first define the vertices of the polygon in an array and then use `fillpoly()` to fill the interior of the polygon with a specific color.

#### Syntax:
```c
void fillpoly(int numpoints, int *points);
```
- **`numpoints`**: The number of points in the polygon.
- **`points`**: An array containing the coordinates of the vertices in the format `(x1, y1, x2, y2, ..., xn, yn)`.

#### Example: Filling a Polygon
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    int points[] = {100, 100, 200, 50, 300, 100, 250, 150, 150, 150};  // Polygon vertices
    setfillstyle(SOLID_FILL, BLUE);  // Set fill color to blue
    fillpoly(5, points);  // Draw and fill the polygon

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `fillpoly(5, points)` draws and fills a polygon with 5 vertices using the coordinates provided in the `points` array.

---

### **4. Flood Fill: `floodfill()`**
The **flood fill** algorithm is used to fill an area surrounded by a boundary with a color. It works by starting from a point inside the boundary and changing the color of all connected pixels to the fill color.

#### Syntax:
```c
void floodfill(int x, int y, int bordercolor);
```
- **`x, y`**: Coordinates of the point inside the shape to start filling.
- **`bordercolor`**: The color used to define the boundary of the fill area.

#### Example: Flood Fill
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    setfillstyle(SOLID_FILL, GREEN);  // Set fill color to green
    rectangle(50, 50, 200, 200);  // Draw a rectangle

    floodfill(100, 100, WHITE);  // Fill the inside of the rectangle with green color

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `floodfill(100, 100, WHITE)` starts filling from point (100, 100) and fills the inside of the rectangle with the color set by `setfillstyle()`.

---

### **5. Color Spraying (Simulating Spray Filling)**
Color spraying or spray filling is a technique used to simulate the effect of spraying color over an area. This effect is often seen in art programs, where the user can paint freely within a confined area.

While `graphics.h` does not have a direct "spray" function, you can simulate this effect by repeatedly drawing small circles with random radii and positions, creating a spray-like effect.

#### Example: Simulating Spray Fill
```c
#include <graphics.h>
#include <conio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    setfillstyle(SOLID_FILL, YELLOW);  // Set fill color to yellow
    srand(time(0));  // Initialize random number generator

    for (int i = 0; i < 1000; i++) {
        int x = rand() % 300 + 50;  // Random x coordinate within the rectangle
        int y = rand() % 300 + 50;  // Random y coordinate within the rectangle
        circle(x, y, rand() % 3 + 1);  // Draw small circles to simulate spray
    }

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- This program creates a "spray" effect by randomly drawing small circles at different positions within a defined area.

---

### Key Points:
- **`setfillstyle()`**: Defines the filling pattern and color for shapes.
- **`fillellipse()`**: Fills an ellipse with the current fill style.
- **`fillpoly()`**: Fills a polygon with the current fill style, based on specified vertices.
- **`floodfill()`**: Fills an enclosed area starting from a point inside it, bounded by a specific border color.
- **Spray Filling**: Can be simulated by randomly drawing small circles within a specified area to create a spray effect.

---

## Filling Styles and Patterns

### Introduction to Filling Styles and Patterns in Graphics
In computer graphics, **filling styles** and **patterns** refer to the visual styles used to fill shapes like rectangles, polygons, ellipses, and more. These styles and patterns can be solid colors, gradients, or even complex textures. By customizing filling styles and patterns, you can make graphics more visually appealing and dynamic.

In C, specifically with libraries like **graphics.h**, filling styles are used in conjunction with functions like `setfillstyle()` to determine how the interior of shapes should be filled. These filling styles can be used to fill simple shapes or more complex polygons, and various patterns can be applied to customize the appearance.

ðŸ’¡ **TIP:** Mastering different fill styles and patterns can make your graphics programming more versatile, allowing you to create visually engaging designs.

---

### **1. `setfillstyle()` Function**
The **`setfillstyle()`** function is used to specify how the interior of a shape should be filled. It takes two arguments:
- **Pattern**: The fill pattern, which could be a solid color, a crosshatch, or a variety of other predefined patterns.
- **Color**: The color used for the fill pattern.

#### Syntax:
```c
void setfillstyle(int pattern, int color);
```
- **`pattern`**: Specifies the fill pattern (e.g., solid, crosshatch, etc.).
- **`color`**: The color used to fill the shape.

#### Example: Using `setfillstyle()` to Define Fill Pattern and Color
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Set the fill pattern to SOLID_FILL and color to GREEN
    setfillstyle(SOLID_FILL, GREEN);
    
    // Draw and fill a rectangle
    rectangle(50, 50, 200, 200);
    floodfill(100, 100, WHITE);  // Fill with the set color and pattern

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `setfillstyle(SOLID_FILL, GREEN)` sets the fill pattern to solid color and the fill color to green.
- `floodfill(100, 100, WHITE)` fills the inside of the rectangle with the green color.

---

### **2. Predefined Fill Patterns**
There are several predefined fill patterns available in `graphics.h`. The most commonly used fill patterns are:

- **`SOLID_FILL`**: A solid color fill.
- **`LINE_FILL`**: A fill with a line pattern.
- **`LTSLASH_FILL`**: A fill with light slashes.
- **`SLASH_FILL`**: A fill with slashes.
- **`BKSHADE_FILL`**: A fill with a shaded background.
- **`XHATCH_FILL`**: A fill with a crosshatch pattern.
- **`DOT_FILL`**: A fill with dots.
- **`PATTERN_FILL`**: A fill with a custom pattern.

#### Example: Using Different Fill Patterns
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Set the fill pattern to crosshatch and color to BLUE
    setfillstyle(XHATCH_FILL, BLUE);
    rectangle(50, 50, 200, 200);
    floodfill(100, 100, WHITE);  // Fill with the set pattern and color

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- `setfillstyle(XHATCH_FILL, BLUE)` sets the fill pattern to crosshatch and the fill color to blue.

---

### **3. Color and Fill Pattern Combinations**
The **color** argument in the `setfillstyle()` function defines the color of the pattern. You can combine different fill patterns with different colors to create unique visual effects in your shapes.

#### Example: Using `setfillstyle()` with Different Patterns
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Set the fill pattern to SLASH_FILL and color to YELLOW
    setfillstyle(SLASH_FILL, YELLOW);
    rectangle(50, 50, 200, 200);
    floodfill(100, 100, WHITE);  // Fill with the set pattern and color

    // Set the fill pattern to DOT_FILL and color to RED
    setfillstyle(DOT_FILL, RED);
    circle(300, 150, 50);
    floodfill(300, 150, WHITE);  // Fill with the set pattern and color

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- The first rectangle is filled with the SLASH_FILL pattern and yellow color.
- The second circle is filled with the DOT_FILL pattern and red color.

---

### **4. Using `fillpoly()` with Fill Patterns**
You can also fill polygons with patterns using the `fillpoly()` function. First, you define the vertices of the polygon and then use `setfillstyle()` to specify how the interior of the polygon should be filled.

#### Example: Filling a Polygon with a Pattern
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    int points[] = {100, 100, 200, 50, 300, 100, 250, 150, 150, 150};
    setfillstyle(LTSLASH_FILL, GREEN);  // Set fill pattern and color
    fillpoly(5, points);  // Fill the polygon with the set pattern

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- The polygon formed by the vertices is filled with the LTSLASH_FILL pattern and green color.

---

### **5. Flood Fill with Different Patterns: `floodfill()`**
The `floodfill()` function is used to fill an enclosed area starting from a specified point. You can also fill the area with a specific pattern or color. 

#### Syntax:
```c
void floodfill(int x, int y, int bordercolor);
```
- **`x, y`**: Coordinates of the point inside the shape to start filling.
- **`bordercolor`**: The color used to define the boundary of the fill area.

#### Example: Flood Filling with a Custom Pattern
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    setfillstyle(SOLID_FILL, BLUE);  // Set fill color to blue
    rectangle(50, 50, 200, 200);
    floodfill(100, 100, WHITE);  // Flood fill the rectangle with blue

    setfillstyle(LTSLASH_FILL, YELLOW);  // Set fill pattern and color
    circle(300, 150, 50);
    floodfill(300, 150, WHITE);  // Flood fill the circle with the yellow pattern

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- The first shape (rectangle) is filled with a solid blue color.
- The second shape (circle) is filled with the LTSLASH_FILL pattern and yellow color using `floodfill()`.

---

### **6. Advanced Pattern Fills**
Advanced pattern fills allow for more complex patterns, like using bitmap images or creating unique patterns for filling the shapes. For example, `graphics.h` allows for loading user-defined patterns using the `setpattern()` function.

#### Example: Using Custom Pattern Fill (Advanced)
```c
#include <graphics.h>
#include <conio.h>

// Custom pattern can be defined or loaded here (using setpattern() or other functions)

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    setfillstyle(SOLID_FILL, BLUE);  // Use a solid color fill
    rectangle(50, 50, 200, 200);
    floodfill(100, 100, WHITE);  // Fill the rectangle with blue

    getch();
    closegraph();
    return 0;
}
```

**Explanation:**
- This example shows the use of a solid color for the fill. More advanced techniques involve loading custom patterns or bitmaps as fill patterns.

---

### Key Points:
- **`setfillstyle()`**: Specifies the filling pattern and color for shapes.
- **Fill Patterns**: Predefined patterns like `SOLID_FILL`, `SLASH_FILL`, `LTSLASH_FILL`, etc., can be used for various visual effects.
- **Flood Fill**: `floodfill()` can be used to fill an enclosed area with a specific color or pattern, starting from a given point inside the shape.
- **Advanced Fills**: Custom patterns or images can be used for more complex visual effects.

---

## Understand Animation and Functions to Create Animation

### Introduction to Animation in Graphics
Animation in computer graphics involves creating the illusion of motion by displaying a series of images, or frames, in quick succession. These frames can either be static images or parts of a larger image, creating a smooth, continuous transition when viewed at a high speed. In C graphics programming, animation can be achieved by drawing shapes, updating their positions, and redrawing them in different locations over time.

ðŸ’¡ **TIP:** Understanding the basics of animation is key to creating dynamic and interactive graphical programs. Animation can be used for everything from simple movement of objects to more complex visual effects.

---

### **1. Basics of Animation**
Animation works by displaying a series of images, called **frames**, one after another. The frames are created by:
- Moving objects (shapes, images) to new positions.
- Updating the screen or window to reflect the new positions.
- Repeating this process to create the illusion of motion.

In computer graphics, the animation process usually involves:
1. **Rendering**: Drawing the shapes or objects at different positions.
2. **Updating**: Changing the position or state of the objects over time.
3. **Refreshing the Screen**: Redrawing the screen each time with the updated positions.

The key to smooth animation is controlling the **frame rate** â€” the number of frames displayed per second (FPS). A higher FPS results in smoother animation.

---

### **2. Frame Rate and Speed**
The **frame rate** determines how fast the animation appears to run. A higher frame rate results in smoother and faster animation. Typical frame rates for animations are:
- **24 frames per second (FPS)**: Standard for film and TV.
- **30 FPS**: Common in video games and web animations.
- **60 FPS**: Provides very smooth animation, often used in gaming and high-quality graphical applications.

In C, you can control the frame rate by introducing a delay between frames using functions like **`delay()`** or **`sleep()`**, which control how long the program waits before rendering the next frame.

#### Example: Using `delay()` to Control Frame Rate
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    int x = 50, y = 100;  // Starting coordinates for the object (e.g., a rectangle)

    while (!kbhit()) {  // Keep animating until a key is pressed
        setcolor(WHITE);
        rectangle(x, y, x + 50, y + 50);  // Draw a rectangle at the current position
        delay(30);  // Delay for 30 milliseconds (controls frame rate)

        setcolor(BLACK);
        rectangle(x, y, x + 50, y + 50);  // Erase the previous rectangle

        x += 5;  // Move the rectangle to the right
        if (x > getmaxx()) {  // If the rectangle reaches the right edge of the screen, reset position
            x = 50;
        }
    }

    closegraph();
    return 0;
}
```

**Explanation:**
- The `delay(30)` function is used to introduce a 30-millisecond delay between frames, making the rectangle move slowly across the screen.
- `kbhit()` checks if a key has been pressed to stop the animation.

---

### **3. Animation Using Functions**
To create animation, you can use different functions for drawing and erasing shapes, such as `rectangle()`, `circle()`, `line()`, etc., in combination with movement and delays.

#### **Animating a Moving Rectangle**
A simple way to animate an object like a rectangle is to continuously update its position and redraw it on the screen.

#### Example: Moving a Rectangle Across the Screen
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    int x = 50, y = 100;  // Initial position of the rectangle

    while (!kbhit()) {
        setcolor(WHITE);
        rectangle(x, y, x + 50, y + 50);  // Draw the rectangle

        delay(50);  // Delay to control animation speed

        setcolor(BLACK);
        rectangle(x, y, x + 50, y + 50);  // Erase the rectangle

        x += 10;  // Move the rectangle to the right

        if (x > getmaxx()) {  // Reset position if the rectangle reaches the right edge
            x = 50;
        }
    }

    closegraph();
    return 0;
}
```

**Explanation:**
- In each loop, `rectangle()` is called to draw the rectangle, followed by a delay to control the speed.
- After drawing the rectangle, the previous rectangle is erased by drawing it in the background color (black).
- The rectangle moves horizontally across the screen by increasing the `x` coordinate.

---

### **4. Creating Animations with Multiple Objects**
To make animations more complex, you can move multiple objects at the same time, or create scenes where several objects interact. For example, you could animate several shapes (a circle, a line, a rectangle) moving across the screen simultaneously.

#### Example: Moving Multiple Objects
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    int x1 = 50, y1 = 100;  // Starting position of the rectangle
    int x2 = 50, y2 = 150;  // Starting position of the circle

    while (!kbhit()) {
        // Draw the rectangle
        setcolor(WHITE);
        rectangle(x1, y1, x1 + 50, y1 + 50);

        // Draw the circle
        circle(x2, y2, 30);

        delay(30);  // Delay for animation speed

        // Erase the previous rectangle and circle
        setcolor(BLACK);
        rectangle(x1, y1, x1 + 50, y1 + 50);
        circle(x2, y2, 30);

        // Move the objects
        x1 += 5;  // Move rectangle
        x2 += 5;  // Move circle

        if (x1 > getmaxx()) x1 = 50;  // Reset the rectangle position
        if (x2 > getmaxx()) x2 = 50;  // Reset the circle position
    }

    closegraph();
    return 0;
}
```

**Explanation:**
- The rectangle and the circle are drawn and erased simultaneously, and both objects move across the screen.
- The `x1` and `x2` coordinates are incremented to move the objects horizontally.

---

### **5. Implementing More Complex Animations**
For more complex animations, such as a character walking or objects interacting, you may need to:
1. **Load Images or Sprites**: For complex objects, you can load pre-created images (sprites) and animate them by changing their position.
2. **Handle User Input**: You can create interactive animations where the user controls an objectâ€™s movement.

#### Example: Simple Animation Using Sprites
```c
#include <graphics.h>
#include <conio.h>

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    // Load a sprite (assuming sprite is a BMP file)
    int sprite = loadimage("sprite.bmp");

    int x = 50, y = 100;  // Starting position of the sprite

    while (!kbhit()) {
        putimage(x, y, sprite, COPY_PUT);  // Draw the sprite at the current position
        delay(50);  // Control animation speed

        x += 5;  // Move the sprite to the right

        if (x > getmaxx()) x = 50;  // Reset the position if the sprite goes off the screen
    }

    closegraph();
    return 0;
}
```

**Explanation:**
- The `loadimage()` function loads an external image (e.g., a BMP file) as a sprite, and `putimage()` places it on the screen at the specified position.
- The sprite moves across the screen and resets when it reaches the edge.

---

### **6. Animation Optimization**
For smooth and efficient animation:
- **Minimize Redrawing**: Avoid unnecessary screen redraws. Only redraw the portions of the screen that need to be updated.
- **Use Double Buffering**: Double buffering involves drawing the next frame off-screen and then copying it to the display once it's ready, reducing flicker.
- **Optimize Delay Time**: Use the right amount of delay to balance performance and smoothness.

---

### Key Points:
- **Frame Rate Control**: Use functions like `delay()` to control the speed of the animation.
- **Movement**: By updating object positions in each frame, you can animate shapes and objects on the screen.
- **Multiple Objects**: Complex animations can involve moving multiple objects, updating their positions in each frame.
- **Interactive Animation**: User input can be used to create animations where the user controls elements (e.g., using the keyboard or mouse).
- **Sprites**: For complex animations, sprites (images) can be loaded and moved across the screen.
- **Optimization**: For smoother animation, consider techniques like minimizing redraws, using double buffering, and adjusting delay times.

---

## Traffic Light and Moving Car Simulation

### Introduction to Traffic Light and Car Simulation
In graphical simulations, traffic lights and moving cars are commonly used to represent real-world traffic systems. A **traffic light** can change between different states (green, yellow, red), and a **moving car** can simulate the movement of vehicles based on these states. Creating such simulations involves understanding animation, object movement, and user input.

In C programming, the **`graphics.h`** library is often used to draw shapes like traffic lights and cars, animate their behavior, and simulate realistic traffic scenarios.

ðŸ’¡ **TIP:** Simulations like these can be enhanced by adding features like pedestrian crossing signals, car acceleration, and smooth transitions between traffic light states.

---

### **1. Basic Concepts for Simulation**
A basic traffic light simulation consists of:
1. **Traffic Light States**: The light can be in one of three states:
   - **Green**: Allows cars to move.
   - **Yellow**: A warning that the light will turn red soon.
   - **Red**: Stops the cars.
2. **Car Movement**: A car should move based on the traffic light's state. When the light is green, the car moves, but when it turns red or yellow, the car stops or slows down.

---

### **2. Drawing the Traffic Light**
To simulate a traffic light, we need to draw a traffic light and represent its three states (green, yellow, and red). This can be done using circles or rectangles to represent the light bulbs and change their colors.

#### Example: Drawing the Traffic Light
```c
#include <graphics.h>
#include <conio.h>
#include <stdlib.h>

void drawTrafficLight(int lightColor) {
    // Draw traffic light body (rectangle)
    setfillstyle(SOLID_FILL, WHITE);
    rectangle(100, 100, 200, 300);
    floodfill(150, 150, WHITE);
    
    // Draw red, yellow, and green lights
    if (lightColor == RED) {
        setfillstyle(SOLID_FILL, RED);
        floodfill(150, 130, WHITE);
    } else {
        setfillstyle(SOLID_FILL, BLACK);
        floodfill(150, 130, WHITE);
    }

    if (lightColor == YELLOW) {
        setfillstyle(SOLID_FILL, YELLOW);
        floodfill(150, 200, WHITE);
    } else {
        setfillstyle(SOLID_FILL, BLACK);
        floodfill(150, 200, WHITE);
    }

    if (lightColor == GREEN) {
        setfillstyle(SOLID_FILL, GREEN);
        floodfill(150, 270, WHITE);
    } else {
        setfillstyle(SOLID_FILL, BLACK);
        floodfill(150, 270, WHITE);
    }
}

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    int lightColor = GREEN;  // Initially set to green
    while (!kbhit()) {
        // Draw the traffic light
        drawTrafficLight(lightColor);
        
        // Change traffic light colors
        delay(1000);  // Delay for 1 second

        if (lightColor == GREEN) {
            lightColor = YELLOW;
        } else if (lightColor == YELLOW) {
            lightColor = RED;
        } else {
            lightColor = GREEN;
        }
    }

    closegraph();
    return 0;
}
```

**Explanation:**
- The traffic light is represented by three colored circles (red, yellow, and green). These are drawn using `setfillstyle()` and `floodfill()`.
- The `lightColor` variable determines which color the light is showing, and it switches between red, yellow, and green in a loop.

---

### **3. Drawing the Moving Car**
A moving car can be represented by a simple rectangle or a more detailed shape if desired. The car's position will change depending on the state of the traffic light. When the light is green, the car moves; when it's red or yellow, the car stops or moves more slowly.

#### Example: Drawing and Moving the Car
```c
#include <graphics.h>
#include <conio.h>
#include <stdlib.h>

void drawCar(int x, int y) {
    // Draw car body (rectangle)
    setfillstyle(SOLID_FILL, BLUE);
    rectangle(x, y, x + 50, y + 30);
    floodfill(x + 25, y + 15, BLUE);
    
    // Draw car wheels (circles)
    setfillstyle(SOLID_FILL, BLACK);
    circle(x + 10, y + 30, 5);
    floodfill(x + 10, y + 30, BLACK);
    
    circle(x + 40, y + 30, 5);
    floodfill(x + 40, y + 30, BLACK);
}

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    int carX = 50, carY = 200;  // Initial position of the car
    int lightColor = GREEN;     // Initial traffic light state
    while (!kbhit()) {
        // Clear previous car position and draw the traffic light
        setfillstyle(SOLID_FILL, WHITE);
        rectangle(0, 0, getmaxx(), getmaxy());
        floodfill(0, 0, WHITE);

        // Draw the traffic light
        drawTrafficLight(lightColor);

        // Draw the car
        drawCar(carX, carY);

        // Move the car if the light is green
        if (lightColor == GREEN) {
            carX += 5;  // Move the car to the right
            if (carX > getmaxx()) {  // Reset car position when it reaches the end
                carX = 50;
            }
        }

        delay(50);  // Delay to control the speed of the car's movement

        // Change traffic light colors
        delay(1000);  // Change light every second

        if (lightColor == GREEN) {
            lightColor = YELLOW;
        } else if (lightColor == YELLOW) {
            lightColor = RED;
        } else {
            lightColor = GREEN;
        }
    }

    closegraph();
    return 0;
}
```

**Explanation:**
- The car is drawn as a rectangle with two circles for wheels.
- The car moves horizontally when the traffic light is green (`carX += 5`). When the light is red or yellow, the car stays in place.
- The light changes every second (`delay(1000)`), switching from green to yellow to red.

---

### **4. Adding Car Stop and Resume Behavior**
To make the simulation more realistic, the car should stop when the light is red and resume moving when the light turns green. This can be controlled by checking the traffic light's state and adjusting the car's movement accordingly.

#### Example: Car Stop and Resume Based on Traffic Light
```c
#include <graphics.h>
#include <conio.h>
#include <stdlib.h>

void drawCar(int x, int y) {
    // Draw car body (rectangle)
    setfillstyle(SOLID_FILL, BLUE);
    rectangle(x, y, x + 50, y + 30);
    floodfill(x + 25, y + 15, BLUE);

    // Draw car wheels (circles)
    setfillstyle(SOLID_FILL, BLACK);
    circle(x + 10, y + 30, 5);
    floodfill(x + 10, y + 30, BLACK);

    circle(x + 40, y + 30, 5);
    floodfill(x + 40, y + 30, BLACK);
}

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "");

    int carX = 50, carY = 200;  // Initial position of the car
    int lightColor = GREEN;     // Initial traffic light state
    while (!kbhit()) {
        // Clear previous car position and draw the traffic light
        setfillstyle(SOLID_FILL, WHITE);
        rectangle(0, 0, getmaxx(), getmaxy());
        floodfill(0, 0, WHITE);

        // Draw the traffic light
        drawTrafficLight(lightColor);

        // Draw the car
        drawCar(carX, carY);

        // Move the car if the light is green
        if (lightColor == GREEN) {
            carX += 5;  // Move the car to the right
            if (carX > getmaxx()) {  // Reset car position when it reaches the end
                carX = 50;
            }
        }

        delay(50);  // Delay to control the speed of the car's movement

        // Change traffic light colors
        delay(1000);  // Change light every second

        if (lightColor == GREEN) {
            lightColor = YELLOW;
        } else if (lightColor == YELLOW) {
            lightColor = RED;
        } else {
            lightColor = GREEN;
        }
    }

    closegraph();
    return 0;
}
```

**Explanation:**
- When the traffic light is **green**, the car moves.
- When the light is **red**, the car stops (i.e., its position does not change).
- The car starts moving again when the light turns green.

---

### **5. Conclusion**
In this simulation, we have created a traffic light that changes between three states (green, yellow, red) and controls the movement of a car accordingly. Key concepts used in this simulation include:
- **Animation**: Moving objects (car) on the screen by continuously updating their positions.
- **Traffic Light States**: Changing the behavior of the car based on the traffic light's state (green = go, red = stop).
- **Basic Graphics Functions**: Using `rectangle()`, `floodfill()`, `delay()`, and other functions to create the visual elements and animations.

This simulation can be further enhanced by adding more cars, creating intersections, and introducing more complex logic for traffic management.
