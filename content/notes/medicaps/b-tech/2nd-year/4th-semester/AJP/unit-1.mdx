---
title: "Unit 1: Advanced Java Programming"
description: Introduction to Generics, Generics Types and Parameterized Types, Wildcards, Java Collection Framework, Collections (Basic Operations, Bulk Operations, Iteration) List, Set, Maps Lambda Expressions - Lambda Type Inference, Lambda Parameters, Lambda Function Body, Returning a Value, From a Lambda Expression, Lambdas as Objects. 
date: 2025-01-18
tags: ["Advanced Java Programming", "4th Semester", "2nd Year", "medicaps university"]
published: true
metadata:
  university: "Medicaps University"
  degree: "B Tech"
  semester: "4th Semester"
  subject: "Advanced Java Programming"
---

---
## Introduction to Generics  

Generics in Java are a powerful feature that allows developers to write flexible, type-safe, and reusable code. They enable types (classes and interfaces) to be parameters when defining classes, interfaces, and methods.

### Why Use Generics?  
- **Type Safety**: Generics enforce compile-time type checking, reducing runtime errors.  
- **Code Reusability**: Write code that works with various data types using a single implementation.  
- **Eliminate Casting**: Generics eliminate the need for explicit type casting, making the code cleaner and easier to read.  

### Key Features of Generics  
1. **Parameterized Types**: Allow you to define a class or method with type parameters.  
2. **Type Inference**: The compiler can infer the generic type from the context, reducing verbosity.  
3. **Bounded Type Parameters**: Restrict the types that can be passed as arguments to type parameters.  

### Syntax of Generics  
A generic class or interface is defined using angle brackets (`< >`) with a type parameter.  

### Advantages of Generics  
- **Increased Code Reusability and Readability**: Write a single generic implementation for multiple data types, making the code more concise and easier to maintain.  
- **Compile-Time Safety**: Generics enforce type checking at compile-time, reducing the likelihood of class cast exceptions at runtime.  
- **Improved Performance**: Avoid the overhead of type conversion and casting, leading to better performance.  

### Disadvantages of Generics  
- **No Direct Support for Primitive Types**: Generics cannot work directly with primitive types (e.g., `int`, `char`). Instead, their wrapper classes like `Integer` and `Character` must be used.  
- **Type Erasure**: Generics are implemented via type erasure, meaning type information is removed at runtime. This limits runtime operations on generic types.

---

## Generic Types and Parameterized Types  

Generics allow developers to create classes, interfaces, and methods that can operate on a specified type. This enhances flexibility and type safety in Java programming.  

### Generic Types  
Generic types define a type parameter in a class, interface, or method. The type parameter is replaced with a concrete type when the code is compiled.  

#### Syntax of Generic Types  
```java
class ClassName<T> {
    // T is a type parameter
    private T data;

    public void setData(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }
}
```
#### **Examples of generic class**
```java
// Generic class
public class Container<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}

// Using the generic class
public class Main {
    public static void main(String[] args) {
        Container<String> stringContainer = new Container<>();
        stringContainer.setItem("Hello, Generics!");
        System.out.println(stringContainer.getItem());  // Output: Hello, Generics!
    }
}
```

### Parameterized Types  

A **parameterized type** is a generic type with a specific type argument. When a generic type is instantiated, its type parameter is replaced with an actual type, ensuring type safety and eliminating the need for casting.  

#### Example of Parameterized Types  
```java
import java.util.ArrayList;
import java.util.List;

public class ParameterizedTypeExample {
    public static void main(String[] args) {
        // Create a parameterized List of Strings
        List<String> stringList = new ArrayList<>();
        
        // Add elements
        stringList.add("Hello");
        stringList.add("Generics");

        // Access elements
        for (String s : stringList) {
            System.out.println(s);
        }
    }
}
```

In this example:

`List<String>` is a parameterized type.
The type parameter T in List`<T>` is replaced with String.

### Multiple Type Parameters  

In Java, you can define a class or method with **multiple type parameters**, enabling greater flexibility and functionality. Multiple type parameters are specified by separating them with commas inside angle brackets (`<>`).  

#### Syntax for Multiple Type Parameters  
```java
class ClassName<T, U> {
    private T first;
    private U second;

    public ClassName(T first, U second) {
        this.first = first;
        this.second = second;
    }

    public T getFirst() {
        return first;
    }

    public U getSecond() {
        return second;
    }
}
```

### Raw Types  

A **raw type** is a generic type that does not specify a type parameter. It is a backward compatibility feature introduced in Java to work with legacy code written before generics were introduced. However, raw types are **not type-safe** and should be avoided in modern Java programming.  

---

#### Example of a Raw Type  
```java
import java.util.ArrayList;
import java.util.List;

public class RawTypeExample {
    public static void main(String[] args) {
        // Using raw type (no type parameter specified)
        List rawList = new ArrayList();
        rawList.add("Hello");
        rawList.add(42);  // Allowed, but type-unsafe

        // Retrieve elements (requires casting)
        String firstItem = (String) rawList.get(0);  // Works
        String secondItem = (String) rawList.get(1);  // Causes ClassCastException
    }
}
```

#### Explanation:  
- `List rawList = new ArrayList();`: The type parameter is omitted, making it a raw type.  
- **Type Safety is Not Enforced**: A raw list can store objects of any type without restrictions.  
- **Type Casting is Required**: When retrieving elements, you must cast them to the appropriate type, which can lead to potential `ClassCastException`.  

---

### Why Avoid Raw Types?  
- **No Compile-Time Type Checking**: Errors that could have been caught during compilation are deferred to runtime.  
- **Risk of Runtime Exceptions**: Improper use of raw types can cause `ClassCastException`.  
- **Lack of Clarity**: Code that uses raw types is more difficult to read, understand, and maintain.  

ðŸ’¡ **TIP**: Always use parameterized types to enforce type safety and improve code readability.  

### Key Points  

- **Generic Types** define classes, interfaces, or methods with a placeholder for types.  
- **Parameterized Types** replace placeholders with specific types during instantiation.  
- Use **generics** for:  
  - **Type Safety**: Prevent runtime errors by ensuring type consistency at compile time.  
  - **Better Performance**: Eliminate the need for type casting and reduce overhead.  
  - **Cleaner Code**: Enhance code readability and maintainability.  

---

## Wildcards  

In Java generics, **wildcards** allow flexibility when working with parameterized types. They are represented by the `?` symbol and are used to specify an unknown type. Wildcards are helpful when you want to limit or relax the type restrictions of generics.  

### Types of Wildcards  
There are three main types of wildcards in Java:  
1. **Unbounded Wildcard (`?`)**  
2. **Upper-Bounded Wildcard (`? extends T`)**  
3. **Lower-Bounded Wildcard (`? super T`)**  

---

### 1. Unbounded Wildcard (`?`)  
The unbounded wildcard can represent any type, without restriction. It is used when the type is unknown, and no operations on the type are required.  

#### Example:  
```java
public class WildcardExample {
    public static void printList(List<?> list) {
        for (Object obj : list) {
            System.out.println(obj);
        }
    }

    public static void main(String[] args) {
        List<String> stringList = List.of("Apple", "Banana");
        List<Integer> intList = List.of(1, 2, 3);

        printList(stringList);
        printList(intList);
    }
}
```

### 2. Upper-Bounded Wildcard (`? extends T`)  

The **upper-bounded wildcard** restricts the unknown type to be a subtype of a specific class. This allows you to read items from a collection, but not modify it (i.e., add elements). The wildcard ensures that only types that are **subtypes** of the specified class are accepted.  

#### Use Case:  
- You can read elements from a collection, but you cannot add elements because the exact type is unknown.  
- This type of wildcard is useful when you want to perform operations that don't require modifying the collection, such as printing or summing the values.  

#### Example:  
```java
public class UpperBoundedWildcard {
    public static void printNumbers(List<? extends Number> list) {
        for (Number num : list) {
            System.out.println(num);
        }
    }

    public static void main(String[] args) {
        List<Integer> intList = List.of(1, 2, 3);
        List<Double> doubleList = List.of(1.1, 2.2, 3.3);

        printNumbers(intList);
        printNumbers(doubleList);
    }
}
```

### 3. Lower-Bounded Wildcard (`? super T`)

The **lower-bounded wildcard** restricts the unknown type to be a supertype of a specific class. This is useful when you want to add elements to a collection, but you are not concerned about the exact type of elements being retrieved. The wildcard ensures that only types that are **supertypes** of the specified class are accepted. 

#### Use Case:  
- You can add elements to a collection, but you cannot retrieve them (except as `Object`).  
- This wildcard is helpful when you want to accumulate elements of a specific type or any of its supertypes.  

#### Example:  
```java
public class LowerBoundedWildcard {
    public static void addNumbers(List<? super Integer> list) {
        list.add(42);  // Allowed because Integer is a subtype of Number
    }

    public static void main(String[] args) {
        List<Number> numList = new ArrayList<>();
        addNumbers(numList);
        System.out.println(numList);
    }
}
```

### Key Points  

- **Wildcards** enable more flexible and dynamic use of generics.  
- **Unbounded Wildcard** allows any type.  
- **Upper-Bounded Wildcard** allows only subtypes of a class.  
- **Lower-Bounded Wildcard** allows only supertypes of a class.  

---

ðŸ’¡ **TIP**: Wildcards provide flexibility when working with generic types, enabling code that can operate on a wider variety of types while maintaining type safety.

---

## Java Collection Framework

The **Java Collection Framework** provides a set of interfaces and classes that implement commonly used collection data structures, such as lists, sets, and maps. It is part of the `java.util` package and helps in storing, retrieving, and manipulating groups of data efficiently.

### Key Interfaces in the Collection Framework  
The core interfaces in the collection framework are:

1. **Collection**  
   - The root interface in the collection hierarchy. It defines the basic operations for adding, removing, and querying elements.  
   - Commonly implemented by `List`, `Set`, and `Queue`.

2. **List**  
   - An ordered collection that allows duplicate elements.  
   - Elements can be accessed by index.  
   - Implemented by classes like `ArrayList`, `LinkedList`, and `Vector`.

3. **Set**  
   - A collection that does not allow duplicate elements.  
   - Typically used when you want to store unique elements.  
   - Implemented by `HashSet`, `LinkedHashSet`, and `TreeSet`.

4. **Queue**  
   - A collection used to hold elements prior to processing.  
   - Typically used in scenarios like task scheduling.  
   - Implemented by `PriorityQueue`, `LinkedList`, etc.

5. **Map**  
   - A collection that stores key-value pairs, where each key is unique.  
   - Not a direct subtype of `Collection`.  
   - Implemented by `HashMap`, `TreeMap`, and `LinkedHashMap`.

---

### Important Classes  
The collection framework includes various classes to implement the above interfaces:

- **ArrayList**  
   - A `List` implementation that uses a dynamic array to store elements.  
   - Provides fast random access and good performance for most operations.

- **HashSet**  
   - A `Set` implementation based on a hash table.  
   - Does not maintain any order of elements and disallows duplicates.

- **TreeSet**  
   - A `Set` implementation that uses a tree structure.  
   - Maintains elements in sorted order (natural or specified order).

- **HashMap**  
   - A `Map` implementation that uses a hash table.  
   - Stores key-value pairs and allows fast retrieval based on keys.

- **LinkedList**  
   - Implements both `List` and `Queue` interfaces.  
   - Provides efficient insertion and removal operations.

---

### Advantages of the Collection Framework  
- **Unified architecture**: Provides a standard way to handle groups of objects.  
- **Efficiency**: Optimized data structures for different use cases (e.g., `ArrayList` for fast access, `HashSet` for uniqueness).  
- **Flexibility**: Allows dynamic resizing of collections, enabling the addition or removal of elements at runtime.  
- **Algorithms**: Provides built-in algorithms for sorting, searching, and other operations.

---

### Key Methods in the Collection Interface  
The `Collection` interface provides various methods that are implemented by its subclasses:

- `add(E e)`: Adds an element to the collection.  
- `remove(Object o)`: Removes a specified element.  
- `size()`: Returns the number of elements in the collection.  
- `contains(Object o)`: Checks if a specified element is present.  
- `clear()`: Removes all elements from the collection.

---

ðŸ’¡ **TIP**: Choose the right collection implementation based on your requirements. For example, use `ArrayList` for fast access, `HashSet` for uniqueness, and `HashMap` for key-value storage.

---

## Collections: Basic Operations, Bulk Operations, and Iteration

In Java, the **Collections** framework provides a wide range of operations for manipulating data. These operations can be categorized into **basic operations**, **bulk operations**, and **iteration** techniques, each serving a specific purpose to handle elements in collections effectively.

---

### 1. Basic Operations

Basic operations are common methods that perform single-element actions on collections. Some of the key basic operations include:

- **add(E e)**  
  Adds the specified element to the collection.  
  Example:  
  ```java
  List<String> list = new ArrayList<>();
  list.add("Apple");

### remove(Object o)

The **remove(Object o)** method removes the specified element from the collection if it exists. If the element is not present, the collection remains unchanged.

#### Example:
```java
List<String> list = new ArrayList<>();
list.add("Apple");
list.add("Banana");
list.add("Orange");

System.out.println("Before removal: " + list);
// Output: [Apple, Banana, Orange]

list.remove("Banana");

System.out.println("After removal: " + list);
// Output: [Apple, Orange]
```

### 2. Bulk Operations

Bulk operations allow performing operations on multiple elements at once, improving efficiency in many use cases.

#### addAll(`Collection<? extends E> c`)

The **addAll(`Collection<? extends E> c`)** method adds all elements from the specified collection to the current collection. This is an efficient way to combine two collections.

#### Example:
```java
List<String> list1 = new ArrayList<>();
list1.add("Apple");
list1.add("Banana");

List<String> list2 = new ArrayList<>();
list2.add("Orange");
list2.add("Grapes");

System.out.println("Before addAll: " + list1);
// Output: [Apple, Banana]

list1.addAll(list2);

System.out.println("After addAll: " + list1);
// Output: [Apple, Banana, Orange, Grapes]
```

```java
// removeAll(Collection<?> c)
// Removes all elements in the current collection that are contained in the specified collection.
Example:
list.removeAll(list2);
```

### 3. Iteration

Iterating over a collection is crucial to accessing and manipulating elements. Java provides several methods for iteration, including traditional loops and newer approaches with the forEach method.

```java
// Using an Iterator
// The Iterator interface provides a way to traverse a collection. Example:

Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
```

```java
// Enhanced For-Loop (For-Each Loop)
// A simpler and more readable way to iterate over collections. Example:

for (String item : list) {
    System.out.println(item);
}
```

### Key Points

- **Basic Operations**: Add, remove, and check for elements in a collection.
- **Bulk Operations**: Perform actions on multiple elements at once (e.g., `addAll`, `removeAll`).
- **Iteration**: Various methods to iterate over collections, including `Iterator`, enhanced `for`-loop, and `forEach` with lambdas.

ðŸ’¡ **TIP**: Use bulk operations when you need to manipulate multiple elements at once for better performance. Iteration techniques should be chosen based on your use case, with the `forEach` method being more concise and modern for Java 8 and above.

---

## List

In Java, the **List** interface is part of the **java.util** package and is a collection that allows duplicate elements and maintains the order of elements. It is an ordered collection (also called a sequence) that can store elements of a specific type.

### Types of Lists
1. **ArrayList**  
   A dynamic array that grows as elements are added.  
   Example:  
   `List<String> list = new ArrayList<>(); list.add("Apple"); list.add("Banana");`

2. **LinkedList**  
   A doubly linked list implementation of the **List** interface.  
   Example:  
   `List<String> list = new LinkedList<>(); list.add("Apple"); list.add("Banana");`

3. **Vector**  
   Similar to **ArrayList**, but synchronized, making it thread-safe.  
   Example:  
   `List<String> list = new Vector<>(); list.add("Apple"); list.add("Banana");`

---

### Key Operations on List

- **add(E e)**  
  Adds the specified element to the list.  
  Example: `list.add("Orange");`

- **get(int index)**  
  Retrieves the element at the specified index.  
  Example: `String item = list.get(0);` // Retrieves the first element

- **remove(int index)**  
  Removes the element at the specified index.  
  Example: `list.remove(1);` // Removes the element at index 1

- **size()**  
  Returns the number of elements in the list.  
  Example: `int size = list.size();`

- **contains(Object o)**  
  Checks if the list contains the specified element.  
  Example: `boolean exists = list.contains("Apple");`

- **set(int index, E element)**  
  Replaces the element at the specified index with the specified element.  
  Example: `list.set(0, "Mango");`

---

### Iterating Over List

- **Using For-Loop**  
  Example: `for (int i = 0; i < list.size(); i++) { System.out.println(list.get(i)); }`

- **Using Enhanced For-Loop**  
  Example: `for (String item : list) { System.out.println(item); }`

- **Using Iterator**  
  Example: `Iterator<String> iterator = list.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); }`

- **Using forEach (Java 8 and above)**  
  Example: `list.forEach(item -> System.out.println(item));`

---

### Key Points

- The **List** interface allows duplicate elements and maintains order.
- Lists can be implemented using **ArrayList**, **LinkedList**, and **Vector**.
- Common operations include adding, retrieving, removing, and modifying elements.
- Iteration can be done using traditional for-loops, enhanced for-loops, **Iterator**, and **forEach** in Java 8+.

---

ðŸ’¡ **TIP**: Choose the right implementation of **List** based on your performance needs. **ArrayList** is generally faster for random access, while **LinkedList** is more efficient for frequent insertions and deletions.

---

## Set

In Java, the **Set** interface is part of the **java.util** package and represents a collection that does not allow duplicate elements. It is used to model mathematical sets and ensures unique elements. A **Set** also does not maintain any specific order (depending on the implementation).

---

### Types of Sets

1. **HashSet**  
   - Implements the **Set** interface using a hash table.  
   - Does not guarantee any specific order of elements.  
   Example:  
   `Set<String> set = new HashSet<>(); set.add("Apple"); set.add("Banana");`

2. **LinkedHashSet**  
   - Maintains the insertion order of elements.  
   Example:  
   `Set<String> set = new LinkedHashSet<>(); set.add("Apple"); set.add("Banana");`

3. **TreeSet**  
   - Implements the **Set** interface using a tree structure.  
   - Maintains elements in their natural order or by a specified comparator.  
   Example:  
   `Set<String> set = new TreeSet<>(); set.add("Apple"); set.add("Banana");`

---

### Key Operations on Set

- **add(E e)**  
  Adds the specified element to the set. If the element already exists, it is ignored.  
  Example: `set.add("Orange");`

- **remove(Object o)**  
  Removes the specified element from the set.  
  Example: `set.remove("Banana");`

- **contains(Object o)**  
  Checks if the set contains the specified element.  
  Example: `boolean exists = set.contains("Apple");`

- **size()**  
  Returns the number of elements in the set.  
  Example: `int size = set.size();`

- **clear()**  
  Removes all elements from the set.  
  Example: `set.clear();`

---

### Iterating Over Set

- **Using Enhanced For-Loop**  
  Example: `for (String item : set) { System.out.println(item); }`

- **Using Iterator**  
  Example: `Iterator<String> iterator = set.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); }`

- **Using forEach (Java 8 and above)**  
  Example: `set.forEach(item -> System.out.println(item));`

---

### Key Points

- **HashSet**: Fast for operations like adding, removing, and checking elements but does not guarantee order.
- **LinkedHashSet**: Maintains insertion order with slightly lower performance than **HashSet**.
- **TreeSet**: Maintains sorted order but has higher performance costs compared to **HashSet**.

ðŸ’¡ **TIP**: Use **HashSet** for maximum performance when order does not matter, **LinkedHashSet** for predictable iteration order, and **TreeSet** for sorted collections.

---

## Maps

In Java, a **Map** is part of the **java.util** package and is used to store key-value pairs. Each key is unique, and each key maps to exactly one value. Common implementations include **HashMap**, **LinkedHashMap**, and **TreeMap**.

---

### Types of Maps

1. **HashMap**  
   - Implements the **Map** interface using a hash table.  
   - Does not guarantee any order of keys.  
   Example:  
   `Map<String, Integer> map = new HashMap<>(); map.put("Apple", 1); map.put("Banana", 2);`

2. **LinkedHashMap**  
   - Maintains the insertion order of keys.  
   Example:  
   `Map<String, Integer> map = new LinkedHashMap<>(); map.put("Apple", 1); map.put("Banana", 2);`

3. **TreeMap**  
   - Implements the **Map** interface using a tree structure.  
   - Maintains keys in sorted order.  
   Example:  
   `Map<String, Integer> map = new TreeMap<>(); map.put("Apple", 1); map.put("Banana", 2);`

---

### Key Operations on Map

- **put(K key, V value)**  
  Inserts or updates a key-value pair into the map.  
  Example:  
  `map.put("Orange", 3);`

- **get(Object key)**  
  Retrieves the value associated with the specified key.  
  Example:  
  `int value = map.get("Apple");`

- **remove(Object key)**  
  Removes the key-value pair associated with the specified key.  
  Example:  
  `map.remove("Banana");`

- **containsKey(Object key)**  
  Checks if the map contains the specified key.  
  Example:  
  `boolean exists = map.containsKey("Apple");`

- **containsValue(Object value)**  
  Checks if the map contains the specified value.  
  Example:  
  `boolean exists = map.containsValue(2);`

- **size()**  
  Returns the number of key-value pairs in the map.  
  Example:  
  `int size = map.size();`

- **clear()**  
  Removes all key-value pairs from the map.  
  Example:  
  `map.clear();`

---

### Iterating Over a Map

- **Using For-Each Loop with EntrySet**  
  Example:  
  `for (Map.Entry<String, Integer> entry : map.entrySet()) { System.out.println(entry.getKey() + " = " + entry.getValue()); }`

- **Using KeySet and For-Each**  
  Example:  
  `for (String key : map.keySet()) { System.out.println(key + " = " + map.get(key)); }`

- **Using Iterator**  
  Example:  
  `Iterator<Map.Entry<String, Integer>> iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry<String, Integer> entry = iterator.next(); System.out.println(entry.getKey() + " = " + entry.getValue()); }`

- **Using forEach (Java 8 and above)**  
  Example:  
  `map.forEach((key, value) -> System.out.println(key + " = " + value));`

---

### Key Points

- **HashMap**: Fast and efficient for storing key-value pairs without any specific order.  
- **LinkedHashMap**: Maintains insertion order, useful when order matters.  
- **TreeMap**: Maintains keys in a natural or custom-defined sorted order.  
- Use the appropriate implementation based on your requirements for order and performance.

ðŸ’¡ **TIP**: Use **HashMap** for general-purpose key-value storage, **LinkedHashMap** for predictable order, and **TreeMap** for sorted keys.

---

## Lambda Expressions

A **Lambda Expression** in Java is a concise way to represent an anonymous function. Introduced in Java 8, it simplifies the syntax for implementing functional interfaces and enhances readability and code efficiency.

---

### Syntax of Lambda Expressions

The syntax of a lambda expression looks like this:  
`(parameter1, parameter2, ...) -> { body of the function }`

- **Parameters**: Input values for the lambda function (can be omitted if there's only one parameter).  
- **Arrow Token (`->`)**: Separates the parameters from the body.  
- **Body**: Contains the logic or operations for the lambda expression.

---

### Example of Lambda Expression

Without Lambda Expression:  
`Runnable runnable = new Runnable() { public void run() { System.out.println("Running without lambda!"); } }; runnable.run();`

With Lambda Expression:  
`Runnable lambdaRunnable = () -> System.out.println("Running with lambda!"); lambdaRunnable.run();`

---

### Key Features of Lambda Expressions

1. **No Need for Boilerplate Code**: Reduces the verbosity of anonymous class implementation.  
2. **Improves Readability**: Code becomes cleaner and more expressive.  
3. **Supports Functional Programming**: Works with functional interfaces to enable declarative-style programming.

---

### Functional Interfaces and Lambda Expressions

A **functional interface** is an interface with a single abstract method (SAM). Common examples include **Runnable**, **Callable**, **Comparator**, and interfaces from the **java.util.function** package.

#### Example: Using a Predicate

`Predicate<Integer> isEven = num -> num % 2 == 0; System.out.println(isEven.test(4)); // true System.out.println(isEven.test(5)); // false`

---

### Common Use Cases of Lambda Expressions

1. **Iterating Over Collections**  
`List<String> names = Arrays.asList("Alice", "Bob", "Charlie"); names.forEach(name -> System.out.println(name));`

2. **Sorting with Comparator**  
`List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5); numbers.sort((a, b) -> a - b); System.out.println(numbers); // [1, 1, 3, 4, 5]`

3. **Threads with Runnable**  
`Thread thread = new Thread(() -> System.out.println("Thread running with lambda!")); thread.start();`

---

### Key Points

- **Lambda Expressions** simplify working with functional interfaces.  
- They enable cleaner and more concise code by reducing boilerplate syntax.  
- Commonly used in collections, threading, and functional programming.  
- Introduced in Java 8, making Java more functional-programming-friendly.

ðŸ’¡ **TIP**: Use lambdas wherever you need a simple implementation of a functional interface to improve readability and reduce code verbosity.

---

## Lambda Type Inference

**Lambda Type Inference** allows Java to infer the types of parameters in a lambda expression based on the context, reducing the need for explicit type declarations.

---

### How Type Inference Works

When using lambda expressions, the compiler determines the parameter types by analysing the target functional interface's method signature.  
For example:  
`(parameter1, parameter2, ...) -> { body of the function }`

In most cases, you can omit the parameter types, and Java will infer them automatically.

---

### Example: Type Inference

Without Type Inference:  
`Comparator<String> comparator = (String a, String b) -> a.compareTo(b);`

With Type Inference:  
`Comparator<String> comparator = (a, b) -> a.compareTo(b);`

---

### Key Points About Lambda Type Inference

1. **Simplifies Code**  
   Explicit types are often unnecessary, leading to cleaner and more concise code.

2. **Works with Multiple Parameters**  
   The compiler can infer types for multiple parameters based on the functional interface.

Example:  
`BiFunction<Integer, Integer, Integer> sum = (a, b) -> a + b;`

3. **Compatibility with Generic Types**  
   Type inference also works with generics.  

Example:  
`List<String> names = Arrays.asList("Alice", "Bob", "Charlie"); names.sort((a, b) -> a.compareToIgnoreCase(b));`

---

### Constraints of Lambda Type Inference

1. **Ambiguity**: If the compiler cannot determine the type, you'll need to explicitly specify it.  
2. **Readable Code**: While type inference simplifies code, adding explicit types may improve clarity in complex expressions.

---

### Key Points

- **Type inference** simplifies lambda expressions by omitting explicit parameter types.  
- It enhances readability and reduces boilerplate code.  
- Works seamlessly with functional interfaces, collections, and generic types.  
- Use explicit types when clarity or disambiguation is required.

ðŸ’¡ **TIP**: Use type inference for concise, readable code, but donâ€™t hesitate to add explicit types if it improves understanding.

---

## Lambda Parameters

In Java, **lambda parameters** define the inputs for a lambda expression. The number and type of parameters depend on the method signature of the target functional interface.

---

### Types of Lambda Parameters

1. **No Parameters**  
   A lambda expression can have no parameters. Parentheses are mandatory.  
   Example:  
   `(Runnable runnable = () -> System.out.println("No parameters in this lambda!"); runnable.run();)`

2. **Single Parameter**  
   If there is one parameter, parentheses are optional.  
   Example:  
   `Consumer<String> printName = name -> System.out.println("Hello, " + name + "!"); printName.accept("Alice");`

3. **Multiple Parameters**  
   For multiple parameters, parentheses are required.  
   Example:  
   `BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b; System.out.println("Sum: " + add.apply(5, 3)); // Output: Sum: 8`

---

### Rules for Lambda Parameters

1. **Type Declaration**  
   You can explicitly declare the parameter types, though itâ€™s often unnecessary due to type inference.  
   Example:  
   `BiFunction<String, String, String> concatenate = (String a, String b) -> a + b; System.out.println(concatenate.apply("Hello", " World!")); // Output: Hello World!`

2. **Omitting Types**  
   If the compiler can infer types, you can omit them for brevity.  
   Example:  
   `BiFunction<String, String, String> concatenate = (a, b) -> a + b; System.out.println(concatenate.apply("Hello", " World!")); // Output: Hello World!`

---

### Key Points

- Lambda expressions can have **no parameters**, a **single parameter**, or **multiple parameters**.
- Type inference allows you to omit explicit parameter types for cleaner and more concise code.
- Parentheses are mandatory for **no parameters** and **multiple parameters** but optional for a single parameter.

ðŸ’¡ **TIP**: Use type inference to simplify lambda expressions, but ensure clarity in complex cases.

---

## Lambda Function Body

The **body** of a lambda expression contains the logic that defines what the lambda does. Depending on the complexity, the function body can either be a **single expression** or a **block of code**.

---

### Types of Lambda Body

1. **Single Expression (Expression Lambda)**  
   The body can be a single expression, which is evaluated and returned automatically. This type of lambda expression doesn't require the `return` keyword for returning values.  
   Example:  
   `(Function<Integer, Integer> square = x -> x * x; System.out.println(square.apply(4)); // Output: 16)`

2. **Block of Code (Block Lambda)**  
   The body can also contain multiple statements. In this case, you must enclose the code in curly braces `{}` and explicitly use the `return` keyword for returning a value if needed.  
   Example:  
   `(BiFunction<Integer, Integer, Integer> add = (a, b) -> { int result = a + b; return result; }; System.out.println(add.apply(5, 3)); // Output: 8)`

---

### Key Points About Lambda Function Body

1. **Single Expression Lambda**  
   - More concise.  
   - The result of the expression is automatically returned.

2. **Block Lambda**  
   - More flexibility, allowing multiple statements.  
   - Requires `return` for returning values if applicable.

---

### Example Comparisons

- **Expression Lambda**:  
  `Function<Integer, Integer> square = x -> x * x; System.out.println(square.apply(4)); // Output: 16`

- **Block Lambda**:  
  `BiFunction<Integer, Integer, Integer> add = (a, b) -> { int result = a + b; return result; }; System.out.println(add.apply(5, 3)); // Output: 8`

---

### Key Takeaways

- The lambda body can either be a **single expression** or a **block of code**.
- **Single expression lambdas** are concise and do not require the `return` keyword.
- **Block lambdas** are more flexible and require explicit `return` when returning a value.

ðŸ’¡ **TIP**: Use single-expression lambdas for simple cases, and block lambdas when you need multiple statements or control flow.

---

## Returning a Value

In Java, a **lambda expression** can return a value depending on its functional interface's return type. The return value is either derived from the **expression body** or explicitly returned using the `return` keyword in a **block body**.

---

### Returning a Value in a Single Expression Lambda

In a **single expression lambda**, the result of the expression is implicitly returned. You do not need to use the `return` keyword.

Example:  
`Function<Integer, Integer> square = x -> x * x; System.out.println(square.apply(4)); // Output: 16`

Here, the value `x * x` is automatically returned as the result of the lambda expression.

---

### Returning a Value in a Block Lambda

In a **block lambda**, you must use the `return` keyword to return a value. The body can contain multiple statements.

Example:  
`BiFunction<Integer, Integer, Integer> add = (a, b) -> { int result = a + b; return result; }; System.out.println(add.apply(5, 3)); // Output: 8`

In this case, the value `result` is explicitly returned using the `return` keyword.

---

### Key Points About Returning a Value

1. **Single Expression Lambda**:  
   - The return value is automatically derived from the expression.
   - No need to use the `return` keyword.

2. **Block Lambda**:  
   - You must explicitly use the `return` keyword to return a value.
   - Useful when multiple statements are needed in the lambda body.

---

### Example Comparisons

- **Single Expression Lambda**:  
  `Function<Integer, Integer> square = x -> x * x; System.out.println(square.apply(4)); // Output: 16`

- **Block Lambda**:  
  `BiFunction<Integer, Integer, Integer> add = (a, b) -> { int result = a + b; return result; }; System.out.println(add.apply(5, 3)); // Output: 8`

---

### Key Takeaways

- **Single expression lambdas** automatically return the result of the expression.
- **Block lambdas** require an explicit `return` statement to return a value.

ðŸ’¡ **TIP**: Use single expression lambdas when possible for simplicity, but block lambdas are more flexible for complex logic.

---

## Returning a Value From a Lambda Expression

In Java, lambda expressions can return values depending on their functional interface. The return value is either directly derived from a **single expression lambda** or explicitly returned in a **block lambda**.

---

### Single Expression Lambda

For a **single expression lambda**, the result of the expression is implicitly returned, and thereâ€™s no need to use the `return` keyword.

Example:  
`Function<Integer, Integer> square = x -> x * x; System.out.println(square.apply(4)); // Output: 16`

Here, `x * x` is directly returned as the result of the expression.

---

### Block Lambda

For a **block lambda**, you must use the `return` keyword to return a value. A block lambda can have multiple statements inside its body.

Example:  
`BiFunction<Integer, Integer, Integer> add = (a, b) -> { int result = a + b; return result; }; System.out.println(add.apply(5, 3)); // Output: 8`

Here, the result is explicitly returned from the lambda expression using the `return` keyword.

---

### Key Points About Returning a Value

1. **Single Expression Lambda**:  
   - The value is automatically returned.
   - No `return` keyword is needed.
   
2. **Block Lambda**:  
   - Multiple statements are allowed in the lambda body.
   - The `return` keyword must be used to return a value.

---

### Example Comparisons

- **Single Expression Lambda**:  
  `Function<Integer, Integer> square = x -> x * x; System.out.println(square.apply(4)); // Output: 16`

- **Block Lambda**:  
  `BiFunction<Integer, Integer, Integer> add = (a, b) -> { int result = a + b; return result; }; System.out.println(add.apply(5, 3)); // Output: 8`

---

### Key Takeaways

- **Single expression lambdas** automatically return the result of the expression.
- **Block lambdas** require an explicit `return` statement.

ðŸ’¡ **TIP**: Use single expression lambdas for simplicity and readability when possible.

---

## Lambdas as Objects

In Java, **lambdas** are treated as **objects** that can be assigned to variables, passed as arguments, or returned from methods. A lambda expression represents an instance of a functional interface, and the Java compiler treats it as an implementation of that interface.

---

### Lambda Expression as an Object

A lambda expression implements a functional interface, and you can assign it to a variable of the interface type, just like any object. The type of the variable will be the type of the functional interface that the lambda expression implements.

Example:  
```java
@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);
}

public class LambdaAsObject {
    public static void main(String[] args) {
        MathOperation addition = (a, b) -> a + b;  // Lambda expression as an object
        System.out.println(addition.operate(5, 3)); // Output: 8
    }
}
```

## Passing Lambda as Arguments

You can pass lambdas as arguments to methods that expect a functional interface type. This is one of the key features of functional programming in Java.

---

### Example

In the example below, the lambda expression `(a, b) -> a + b` is passed as an argument to the `performOperation` method, which expects a `MathOperation` functional interface type.

```java
@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);
}

public class LambdaAsArgument {
    public static void main(String[] args) {
        performOperation(5, 3, (a, b) -> a + b);  // Passing lambda as an argument
    }

    public static void performOperation(int a, int b, MathOperation operation) {
        System.out.println(operation.operate(a, b));
    }
}
```

## Returning Lambda Expressions from Methods

You can return lambda expressions from methods, and the returned lambda can be assigned to a variable of the functional interface type. This allows methods to dynamically provide behavior that can be used later.

---

### Example

In the example below, the method `getOperation` returns a lambda expression, which is assigned to the variable `multiplication` of type `MathOperation`.

```java
@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);
}

public class LambdaAsReturn {
    public static void main(String[] args) {
        MathOperation multiplication = getOperation();  // Lambda returned from a method
        System.out.println(multiplication.operate(4, 2)); // Output: 8
    }

    public static MathOperation getOperation() {
        return (a, b) -> a * b;  // Returning a lambda expression
    }
}
```

### Explanation:

- The method `getOperation` returns a lambda expression `(a, b) -> a * b`, which implements the `MathOperation` interface.
- The returned lambda is assigned to the variable `multiplication`, which is then used to perform multiplication on the numbers `4` and `2`.

---

### Key Points:

1. **Returning Behavior**:  
   Methods can return lambda expressions, allowing dynamic behavior to be assigned to variables.

2. **Functional Interface**:  
   The returned lambda expression implements a functional interface, which is the return type of the method.

---

### Example Comparison:

- **Lambda as Return**:  
  `MathOperation multiplication = getOperation();`

- **Method Signature**:  
  `public static MathOperation getOperation()`

---

ðŸ’¡ **TIP**: Returning lambda expressions makes it easy to define reusable behavior and pass it around in Java.

---















