---
title: "Unit 2: Microprocessor & Interfacing"
description: Assembly Language Programming- 8085 instructions set- Instructions, Classifications, Addressing modes, Stack and Subroutines, Delay routines, Counters etc., Programming examples.
date: 2025-01-18
tags: ["Microprocessor & Interfacing", "4th Semester", "2nd Year", "medicaps university"]
published: true
metadata:
  university: "Medicaps University"
  degree: "B Tech"
  semester: "4th Semester"
  subject: "Microprocessor & Interfacing"
---

## Assembly Language Programming  

**Assembly Language** is a low-level programming language that is closely related to the architecture of a microprocessor. It provides a way to directly communicate with the hardware of a microprocessor, using mnemonic codes and symbolic addresses instead of binary code.

---

### 1. **What is Assembly Language?**  
Assembly Language is a human-readable representation of a microprocessor's machine language. It uses **mnemonics** (e.g., `MOV`, `ADD`, `SUB`) to represent machine instructions, which makes programming easier than writing in pure binary code.

#### Key Characteristics:
- **Low-level language**: Close to machine code, but more readable.
- **Processor-specific**: Assembly language instructions are specific to the architecture of the microprocessor.
- **Faster execution**: Because it interacts directly with the hardware, assembly programs are often faster and more efficient than programs written in high-level languages.

---

### 2. **Basic Components of Assembly Language**  

#### a. **Mnemonics**
- **Mnemonics** are symbolic representations of machine instructions. For example:
  - `MOV`: Move data between registers or memory.
  - `ADD`: Add two values.
  - `SUB`: Subtract one value from another.

#### b. **Registers**
- **Registers** are small, fast storage locations within the CPU. Common registers include:
  - **Accumulator (A)**: Stores results of arithmetic operations.
  - **Data registers (B, C, D, E, H, L)**: Used for storing data during processing.

#### c. **Directives**
- **Directives** are instructions that provide instructions to the assembler, but do not generate machine code. For example:
  - `.DATA`: Declares data to be used in the program.
  - `.CODE`: Marks the start of the code section.

---

### 3. **Assembly Language Program Structure**  

A typical assembly program consists of the following sections:

- **Data Segment:** Contains the variables or data to be used in the program.
- **Code Segment:** Contains the actual instructions to be executed.
- **Stack Segment:** Used for managing function calls and local variables.

Example program structure:

```assembly
DATA_SEGMENT
  NUM1 DB 10H
  NUM2 DB 20H
CODE_SEGMENT
  MOV AL, NUM1
  ADD AL, NUM2
  MOV RESULT, AL
```
### 4. **Basic Instructions in Assembly Language**  

#### a. **MOV Instruction**  
The `MOV` instruction is used to transfer data from one location to another.

```assembly
MOV A, B   ; Move the contents of register B into register A
MOV A, 10H ; Move the immediate value 10H into register A
```

#### b. **ADD and SUB Instruction**
```assembly
ADD A, B   ; Add the contents of register B to A
SUB A, C   ; Subtract the contents of register C from A
```
### 5. **Assembling and Running the Program**  

To run an assembly language program:

1. Write the program in an assembly language editor.
2. Assemble the program using an assembler, which translates the program into machine code.
3. Link the object code to create an executable.
4. Run the program on the target microprocessor or emulator.

ðŸ’¡ **TIP:** It's important to understand the architecture of the microprocessor you're programming for, as assembly language instructions are processor-specific.

---

## 8085 Instruction Set

The **8085 microprocessor** has a rich set of instructions that perform various operations, such as data transfer, arithmetic, logic operations, control operations, and branching. These instructions are used to program the 8085 microprocessor.

---

### 1. **Types of Instructions**

The instructions of the 8085 microprocessor can be classified into the following types:

#### a. **Data Transfer Instructions**
These instructions are used to transfer data between registers, memory, or I/O ports.

- `MOV`: Move data from one register to another.
```assembly
MOV A, B  ; Move data from register B to register A
```

- `MVI` : Move immediate data into a register or memory.
```assembly
MVI A, 30H  ; Load the immediate data 30H into register A
```

- `LDA` : Load data from memory into the accumulator.
```assembly
LDA 2500H  ; Load data from memory address 2500H into the accumulator
```

#### b. ** Arithmetic Instructions**
These instructions perform arithmetic operations such as addition, subtraction, etc.

- `ADD`: Add contents of a register or memory to the accumulator.
```assembly
ADD B  ; Add the contents of register B to the accumulator
```

- `SUB`: Subtract contents of a register or memory from the accumulator.
```assembly
SUB B  ; Subtract the contents of register B from the accumulator
```

#### c. **Logical Instructions**
These instructions are used to perform logical operations such as AND, OR, XOR, etc.

- `ANA`: Perform bitwise AND with the accumulator.
```assembly
ANA B  ; Perform AND operation between accumulator and register B
```
- `XRA`: Perform bitwise XOR with the accumulator.
```assembly
XRA C  ; Perform XOR operation between accumulator and register C
```

#### d. **Branching Instructions**
These instructions alter the flow of control in the program.

- `JMP`: Jump to a specified memory address.
```assembly
JMP 2000H  ; Jump to memory address 2000H
```

- `JC`: Jump if carry flag is set.
```assembly
JC 3000H  ; Jump to address 3000H if carry flag is set
```

#### e. **Control Instructions**
These instructions control the operation of the microprocessor.

- `NOP`: No operation, does nothing.
```assembly
NOP  ; No operation instruction
```

- `HLT`: Halt the program execution.
```assembly
HLT  ; Halt the program
```

### 2. **Example Program Using 8085 Instructions**
Here is an example of a program that adds two numbers in memory:
```assembly
LDA 2500H  ; Load the first number from memory
MOV B, A   ; Move the number from accumulator to register B
LDA 2501H  ; Load the second number from memory
ADD B      ; Add the number in register B to the accumulator
STA 2502H  ; Store the result in memory at address 2502H
HLT        ; Halt the program
```

ðŸ’¡ **TIP:** Understanding the instruction set of 8085 is crucial for efficient assembly programming. Each instruction is executed within a clock cycle, and knowing their operations helps in optimizing the code.

---

## 8085 Instructions

The **8085 microprocessor** has a wide variety of instructions that are categorized based on their functionality. These instructions allow the microprocessor to perform operations like data transfer, arithmetic, logic, and branching. Below is an overview of the various types of instructions in 8085.

---

### 1. **Data Transfer Instructions**

These instructions move data from one location to another, either between registers, memory, or I/O ports.

- `MOV`: Move data from one register to another.
  ```assembly
  MOV A, B  ; Move data from register B to register A
```assembly
MVI: Move immediate data to a register or memory.
```

```assembly
MVI A, 30H  ; Load the immediate value 30H into register A
LDA: Load data from memory into the accumulator.
```

```assembly
LDA 2500H  ; Load data from memory address 2500H into the accumulator
STA: Store data from the accumulator into memory.
```

```assembly
STA 2500H  ; Store the contents of accumulator into memory address 2500H
LDAX: Load the accumulator from the memory location pointed by the register pair (either BC or DE).
```

```assembly
LDAX B  ; Load the accumulator from the memory location pointed by BC
STAX: Store the accumulator content into the memory location pointed by the register pair (either BC or DE).
```

```assembly
STAX D  ; Store the accumulator into the memory location pointed by DE
```

### 2. **Arithmetic Instructions**
These instructions perform arithmetic operations such as addition, subtraction, and increment/decrement.

```assembly
ADD: Add the contents of a register or memory to the accumulator.
```

```assembly
ADD B  ; Add the contents of register B to the accumulator
SUB: Subtract the contents of a register or memory from the accumulator.
```

```assembly
SUB B  ; Subtract the contents of register B from the accumulator
INR: Increment the contents of a register or memory.
```

```assembly
INR A  ; Increment the contents of accumulator by 1
DCR: Decrement the contents of a register or memory.
```

```assembly
DCR B  ; Decrement the contents of register B by 1
INX: Increment the register pair (BC, DE, HL).
```

```assembly
INX H  ; Increment register pair HL by 1
DCX: Decrement the register pair (BC, DE, HL).
```

```assembly
DCX D  ; Decrement register pair DE by 1
```

### 3. **Logical Instructions**
These instructions perform logical operations such as AND, OR, XOR, etc.

```assembly
ANA: Perform bitwise AND with the accumulator.
```

```assembly
ANA B  ; Perform AND operation between accumulator and register B
XRA: Perform bitwise XOR with the accumulator.
```

```assembly
XRA A  ; Perform XOR operation between accumulator and itself (clear accumulator)
RLC: Rotate the contents of the accumulator left.
```

```assembly
RLC  ; Rotate the contents of the accumulator left
RRC: Rotate the contents of the accumulator right.
```

```assembly
RRC  ; Rotate the contents of the accumulator right
CPI: Compare the contents of the accumulator with an immediate value.
```

```assembly
CPI 30H  ; Compare the contents of accumulator with the immediate value 30H
```

### 4. **Branching Instructions**
These instructions alter the flow of control in the program.

```assembly
JMP: Jump to a specified memory address.
```

```assembly
JMP 2000H  ; Jump to memory address 2000H
JC: Jump if the carry flag is set.
```

```assembly
JC 3000H  ; Jump to address 3000H if carry flag is set
JZ: Jump if the zero flag is set.
```

```assembly
JZ 4000H  ; Jump to address 4000H if zero flag is set
CALL: Call a subroutine at a specified memory address.
```

```assembly
CALL 5000H  ; Call the subroutine at memory address 5000H
RET: Return from a subroutine.
```

```assembly
RET  ; Return from the current subroutine
```

### 5. **Control Instructions**
These instructions control the operation of the microprocessor.

```assembly
NOP: No operation, does nothing.
```

```assembly
NOP  ; No operation instruction
HLT: Halt the program execution.
```

```assembly
HLT  ; Halt the program
SIM: Set the serial output data bit (SOD) and the serial clock (SCLK).
```

```assembly
SIM  ; Set SOD and SCLK
RIM: Read input data and set the serial input data (SID).
```

```assembly
RIM  ; Read input data and set SID
```

### 6. **Example Program Using 8085 Instructions**
Hereâ€™s an example that adds two numbers stored in memory and stores the result in a third memory location:

```assembly
LDA 2500H  ; Load the first number from memory into the accumulator
MOV B, A   ; Move the number from accumulator to register B
LDA 2501H  ; Load the second number from memory into the accumulator
ADD B      ; Add the number in register B to the accumulator
STA 2502H  ; Store the result in memory at address 2502H
HLT        ; Halt the program
```
ðŸ’¡ **TIP:** Understanding the complete set of instructions and their functions will help you write efficient assembly programs for the 8085 microprocessor.

---

## Classifications

In the context of microprocessors and computing, **classifications** refer to the categorization of microprocessors based on various factors such as data bus width, address bus width, processing capability, and other features. These classifications help in understanding the capability and application of different microprocessors in various systems.

---

### 1. **Based on Data Bus Width**
Microprocessors can be classified according to the width of their data bus, which determines how much data they can handle at once.

- **8-bit Microprocessors**: These microprocessors can process 8 bits of data in one cycle.
  - Example: Intel 8085, Zilog Z80
- **16-bit Microprocessors**: These microprocessors can process 16 bits of data in one cycle.
  - Example: Intel 8086, Intel 8088
- **32-bit Microprocessors**: These microprocessors can process 32 bits of data in one cycle.
  - Example: Intel 80386, Pentium processors
- **64-bit Microprocessors**: These microprocessors can process 64 bits of data in one cycle.
  - Example: Intel Core i7, AMD Ryzen

---

### 2. **Based on Address Bus Width**
The width of the address bus determines how much memory a microprocessor can address.

- **8-bit Address Bus**: These microprocessors can address 256 memory locations.
  - Example: Intel 8085
- **16-bit Address Bus**: These microprocessors can address 65536 memory locations.
  - Example: Intel 8086
- **32-bit Address Bus**: These microprocessors can address 4GB of memory.
  - Example: Intel 80386
- **64-bit Address Bus**: These microprocessors can theoretically address up to 16 exabytes of memory.
  - Example: Intel Core i7

---

### 3. **Based on Instruction Set Architecture (ISA)**
Microprocessors are also classified based on the type of instruction set they use.

- **CISC (Complex Instruction Set Computing)**: These processors have a large set of instructions that can perform complex operations in one or few instructions.
  - Example: Intel 8086, Intel 80486
- **RISC (Reduced Instruction Set Computing)**: These processors have a smaller, simpler set of instructions, often requiring multiple instructions to perform a task that would take one instruction in CISC.
  - Example: ARM processors, MIPS processors

---

### 4. **Based on Application**
Microprocessors can also be classified according to the application or domain in which they are used.

- **General-purpose Microprocessors**: Used in personal computers, laptops, and servers. These are designed for a wide range of tasks.
  - Example: Intel Core i5, AMD Ryzen
- **Embedded Microprocessors**: Used in embedded systems for specific tasks.
  - Example: ARM-based microcontrollers, Intel 8051
- **Digital Signal Processors (DSP)**: These microprocessors are designed for processing digital signals, typically used in audio, video, and image processing.
  - Example: Texas Instruments DSP processors
- **Microcontrollers**: Microprocessors with built-in memory and peripheral interfaces, used in embedded systems.
  - Example: PIC microcontrollers, Arduino

---

### 5. **Based on Processing Capability**
Microprocessors are also classified according to their processing capability.

- **Single-core Microprocessors**: These microprocessors have a single processing unit and can execute one instruction at a time.
  - Example: Intel Pentium 4, AMD Athlon
- **Multi-core Microprocessors**: These microprocessors have multiple cores (processing units), which allows them to execute multiple instructions simultaneously, improving performance.
  - Example: Intel Core i7, AMD Ryzen 7

---

ðŸ’¡ **TIP:** Understanding the classifications of microprocessors helps in selecting the right processor for a specific task or application, optimizing performance and cost.

---

## Addressing Modes

**Addressing modes** refer to the methods used by a microprocessor to access data or operands during program execution. These modes specify how the operand (data) for an instruction is determined. Different addressing modes provide flexibility and efficiency in accessing data, which is essential for the execution of complex operations.

---

### 1. **Immediate Addressing Mode**
In **Immediate Addressing Mode**, the operand is provided directly in the instruction itself. The value is part of the instruction and is immediately available for processing.

- **Example**: 
  ```assembly
  MVI A, 30H  ; Load immediate value 30H into register A


### 2. **Register Addressing Mode**

In **Register Addressing Mode**, the operand is stored in one of the processor's registers. The instruction specifies the register that contains the operand.

- **Example**:
  ```assembly
  MOV A, B  ; Move the contents of register B into register A

### 3. **Direct Addressing Mode**

In **Direct Addressing Mode**, the operand is located at a specified memory address. The instruction directly specifies the address where the operand is located.

- **Example**:
  ```assembly
  LDA 2500H  ; Load the operand from memory address 2500H into the accumulator

### 4. **Indirect Addressing Mode**

In **Indirect Addressing Mode**, the instruction provides a register pair (like **BC**, **DE**, or **HL**) that holds the address of the operand in memory. The operand is accessed indirectly through the register pair.

- **Example**:
  ```assembly
  MOV A, M  ; Move the contents of the memory location pointed by HL register pair into register A

### 5. **Register Indirect Addressing Mode**

In **Register Indirect Addressing Mode**, the operand is found at a memory location specified by the register pair (**BC**, **DE**, **HL**). This allows for more dynamic addressing of data.

- **Example**:
  ```assembly
  MOV A, (HL)  ; Move the contents of the memory location pointed by HL into register A

### 6. **Implicit Addressing Mode**

In **Implicit Addressing Mode**, the operand is implied by the instruction. There is no explicit operand or address provided, and the operation is predefined by the instruction.

- **Example**:
  ```assembly
  INX B  ; Increment the BC register pair

ðŸ’¡ **TIP:** Addressing modes allow the processor to access data in different ways, enabling flexibility and optimization for various programming needs.

---

## Stack and Subroutines

The **stack** and **subroutines** are essential components in assembly language programming. They allow for efficient memory management and function call mechanisms, enabling better organization and modularity of code.

---

### 1. **Stack**

A **stack** is a section of memory used to store data temporarily. It follows the **LIFO (Last In, First Out)** principle, meaning the last data item pushed onto the stack is the first to be popped off.

#### Key Features of the Stack:
- **Push Operation**: Adds data to the top of the stack.
- **Pop Operation**: Removes data from the top of the stack.
- **Stack Pointer (SP)**: A special register that holds the address of the top of the stack.

#### Stack Operations:
- **PUSH**: Adds data onto the stack.
  ```assembly
  PUSH B  ; Push the contents of register pair BC onto the stack

- **POP**: Removes data from the stack.
    ```assembly
    POP B  ; Pop the contents from the stack into register pair BC`

### 2. **Subroutines**

A **subroutine** is a set of instructions that can be executed repeatedly in a program. Subroutines provide a way to reuse code and make programs more modular and easier to maintain.

#### Key Features of Subroutines:
- **CALL**: Initiates a subroutine call.
  ```assembly
  CALL SUB_ROUTINE   ; Call the subroutine

- **RET**: Returns control to the calling program.
    ```assembly
    RET   ; Return from the subroutine

---

## Delay Routines

**Delay routines** are used in assembly programming to introduce a time delay. These are often used when precise timing is needed, for example, in generating a delay for external hardware like LEDs, motors, or other peripherals.

---

### 1. **Purpose of Delay Routines**

Delay routines are essential when the program needs to wait for a certain period before proceeding with the next operation. This could be for tasks such as:
- Generating a time delay for hardware timing
- Waiting for user input
- Synchronizing operations with external devices

---

### 2. **Creating Delay in Assembly Language**

One common way to create a delay in assembly language is by using **loops**. The loop runs a certain number of times, thereby consuming CPU cycles and creating a time delay.

#### Example of a Simple Delay Routine:

```assembly
DELAY:  
  MOV C, 10   ; Load register C with the value 10
LOOP1:   
  MOV B, 255  ; Load register B with the value 255
LOOP2:
  NOP          ; No operation, consumes one cycle
  DCR B        ; Decrement register B
  JNZ LOOP2    ; Jump to LOOP2 if B is not zero
  DCR C        ; Decrement register C
  JNZ LOOP1    ; Jump to LOOP1 if C is not zero
  RET          ; Return from the delay subroutine
```

### Explanation of the Delay Routine:

- The outer loop (using register **C**) runs **10** times.
- The inner loop (using register **B**) runs **255** times.
- The **NOP** (No Operation) instruction consumes one CPU cycle, contributing to the delay.
- The delay can be adjusted by modifying the values in **C** and **B**.

ðŸ’¡ **TIP:** The delay time can be fine-tuned by adjusting the loop count. Higher values will result in longer delays.

---

## Counters

**Counters** are used in assembly language programming to keep track of the number of times an event or operation occurs. They are essential for controlling loops, timing, and monitoring processes in a program.

---

### 1. **Purpose of Counters**

Counters are typically used for:
- **Loop control**: Keeping track of the number of iterations in a loop.
- **Event counting**: Counting occurrences of a particular event or condition.
- **Timing**: Keeping track of time intervals, especially in delay routines or periodic events.

---

### 2. **Using Counters in Assembly Language**

Counters are usually implemented using registers. The counter is incremented or decremented during the execution of the program, and when the counter reaches a specific value, it can trigger a condition or action.

#### Example of a Counter for Loop Control:

```assembly
MOV C, 10     ; Load register C with 10 (number of loop iterations)
LOOP:
  NOP         ; No operation (placeholder for some action)
  DCR C       ; Decrement the counter
  JNZ LOOP    ; Jump to LOOP if the counter (C) is not zero
```
### Explanation of the Counter Example:

- The counter is stored in register **C**.
- The counter starts at **10** and is decremented each time the loop runs.
- The loop continues to execute until the counter reaches zero.

ðŸ’¡ **TIP:** Counters can also be used for timing by adjusting the number of iterations or the delay between each iteration.

---

## Programming Examples

Programming examples help to illustrate the practical application of concepts in assembly language. Below are a few examples showcasing common operations in assembly programming.

---

### 1. **Example 1: Simple Addition**

This example demonstrates adding two numbers stored in registers.

```assembly
MOV A, 10H    ; Load register A with the value 10H (16 in decimal)
MOV B, 20H    ; Load register B with the value 20H (32 in decimal)
ADD A, B      ; Add the value in register B to register A (A = A + B)
```

### Explanation of the Examples:

#### 1. **Example 1: Simple Addition**
- **A = 16** and **B = 32**.
- The result of **A + B = 48** is stored in register **A**.

---

#### 2. **Example 2: Looping and Decrementing**
This example demonstrates a simple loop that decrements a counter until it reaches zero.
```assembly
MOV C, 5      ; Load register C with the value 5 (loop count)
LOOP:
  DCR C       ; Decrement register C
  JNZ LOOP    ; Jump to LOOP if C is not zero
```

- The loop will run **5** times, decrementing **C** with each iteration.
- The loop stops when **C** reaches zero.


### 3. **Example 3: Subroutine Call**
This example demonstrates calling a subroutine and returning from it.

```assembly
CALL SUB_ROUTINE   ; Call the subroutine

SUB_ROUTINE:       ; Subroutine definition
  NOP              ; No operation (placeholder for actions)
  RET              ; Return from subroutine
```

ðŸ’¡ **TIP:** These examples serve as the foundation for more complex assembly programs, where multiple instructions can be combined for specific tasks.


